!----------------------------------------------------------------------------
!    This program bases on the original GEATM.  It refactorys the original
!    GEATM with the new modulization and stratification. The new top layer
!    program is added to embed GEATM wihtin CESM. The output method is 
!    is replaced with the new method to make sure the efficiency.
!     
!    Juanxiong He, 2013-06-30
!----------------------------------------------------------------------------

module geatm_comp_mct
  use mct_mod
  use esmf_mod
  use seq_flds_mod
  use seq_flds_indices
  use seq_cdata_mod
  use seq_infodata_mod
  use seq_timemgr_mod
  use seq_comm_mct, only:seq_comm_iamroot,seq_comm_iamin
  use shr_kind_mod     , only: r8 => shr_kind_r8, cl=>shr_kind_cl
  use shr_file_mod     , only: shr_file_getunit, shr_file_freeunit, &
                               shr_file_setLogUnit, shr_file_setLogLevel, &
                               shr_file_getLogUnit, shr_file_getLogLevel, &
                               shr_file_setIO
  use shr_sys_mod      , only: shr_sys_flush, shr_sys_abort
  
 use geatm_vartype 
 use naqpms_varlist
 use naqpms_gridinfo
 use apm_varlist
 use aqchem_varlist
 use met_fields
 use work_vars
 use module_timing
 use inout3
 use cputime
 use smpsulf_var, only: igassmp,allo_smpchem_var

  public :: geatm_init_mct
  public :: geatm_run_mct
  public :: geatm_final_mct

  private :: geatm_SetgsMap_cam
  private :: geatm_import_mct
  private :: geatm_export_mct
  private :: geatm_domain_cam
 
  integer, parameter  :: nlen = 256     ! Length of character strings

!
! Time averaged counter for flux fields
!
  integer :: avg_count
  integer, parameter :: cam_to_geatm_points = 1000000
  integer,dimension(1:cam_to_geatm_points) :: remap_cami, remap_camj
  real*8,dimension(1:cam_to_geatm_points) :: cam_weight
  integer,dimension(:,:),allocatable ::cam_local_points 

  type wrfgrid_c
  integer :: num_wrfgrid_soil_levels, num_wrfgrid_levels, num_wrfgrid_lat, num_wrfgrid_lon
  real(8),dimension(:),allocatable::sigma
  real(8),dimension(:,:,:),allocatable::u3d,v3d,t3d,qv3d,qi3d,qc3d,rh3d,p3d,z3d,taucldv3d,taucldi3d,&
                                     soilt,soilm,soildepth,soilthick
  real(8),dimension(:,:),allocatable::ps,ht,swdown,raincv,rainncv,clflo,clfmi,clfhi,&
                                   pblh,rmol,ust,u10,v10,t2,q2,rh2,&
                                   tsk,xland, sst, xice, snowh
  end type wrfgrid_c

  type camgrid_c
  integer :: num_camgrid_soil_levels, num_camgrid_levels, num_camgrid_lat, num_camgrid_lon
  real(8),dimension(:,:,:),allocatable::u3d,v3d,t3d,qv3d,qi3d,qc3d,rh3d,p3d,z3d,taucldv3d,taucldi3d,&
                                     soilt,soilm,soildepth,soilthick
  real(8),dimension(:,:),allocatable::xlat,xlon,ps,ht,swdown,raincv,rainncv,clflo,clfmi,clfhi,&
                                   pblh,rmol,ust,u10,v10,t2,q2,rh2,&
                                   tsk,xland, sst, xice, snowh
  end type camgrid_c
  type(camgrid_c):: camgrid
  type(wrfgrid_c):: wrfgrid  

contains

subroutine geatm_init_mct(EClock, cdata_ge, x2c_c1, x2c_c2, c2x_c)
    use geatm_vartype
    include 'mpif.h'
 
    type(ESMF_Clock),intent(in)                 :: EClock
    type(seq_cdata), intent(inout)              :: cdata_ge
    type(mct_aVect), intent(inout)              :: x2c_c1
    type(mct_aVect), intent(inout)              :: x2c_c2
    type(mct_aVect), intent(inout)              :: c2x_c   

    type(mct_gsMap), pointer   :: gsMap_ge
    type(mct_gGrid), pointer   :: dom_ge
    type(seq_infodata_type),pointer :: infodata
   
    integer :: GEATMID    
    integer :: mpicom_atm
    integer :: lsize    
    logical :: exists           ! true if file exists    
    integer :: stepno           ! time step                      
    integer :: dtime_sync       ! integer timestep size
    integer :: currentymd       ! current year-month-day
    integer :: dtime            ! time step increment (sec)
    integer :: geatm_cpl_dt       ! driver geatm coupling time step 
    integer :: dtime_geatm        ! Time-step increment (sec)
    integer :: ymd              ! CAM current date (YYYYMMDD)
    integer :: yr               ! CAM current year
    integer :: mon              ! CAM current month
    integer :: day              ! CAM current day
    integer :: tod              ! CAM current time of day (sec)
    integer :: start_ymd        ! Start date (YYYYMMDD)
    integer :: start_tod        ! Start time of day (sec)
    integer :: ref_ymd          ! Reference date (YYYYMMDD)
    integer :: ref_tod          ! Reference time of day (sec)
    integer :: stop_ymd         ! Stop date (YYYYMMDD)
    integer :: stop_tod         ! Stop time of day (sec)
    integer :: shrlogunit,shrloglev ! old values
    logical,save :: first_time = .true.
    character(len=SHR_KIND_CS) :: calendar  ! Calendar type
    character(len=SHR_KIND_CS) :: starttype ! infodata start type
    integer :: lbnum
    integer :: i, j, k, ne, iiaer, ig, ierr, iisize,mpi_ierr
    integer :: iulog
    integer,dimension(:),allocatable :: cpuid
    integer,dimension(2) ::     buffer
    integer status(MPI_STATUS_SIZE)

    character*40, dimension(102) :: GC_Unit,GC_NAME
    integer :: ifunit95,ifunit96,ifunit97,ifunit98,ifunit99
    integer, dimension(8,200) :: ISNDMRK    
    integer :: KDUSTTOP
    integer :: nzz_out,iwritegas
    integer :: numTGRV
    integer :: itt,it1,iPrintTermGas,IPSMARK
    integer :: idm,iemittype
    integer :: ixy,i0,i02,i03,i04,i05,i00,ia,is,ism,ib5,jb5,igg,itsp,iduc,i05c
    integer :: iwb,ieb,jsb,jeb,ne1
    integer :: iaersp,iaerbin,i04aer
    integer :: i059,i0510,i0511,i0512,i0513,i0514,i0515,i0516
    integer :: i03_1,i03p1,i0_1,i04_so2,i04_hno3,i05_1,i05_2
    real :: hh,dt,dt_naqpms,dt_cbmz,dcost
    integer :: iia,ii,iii,ikl,ikk,IR,icpu
    integer :: ictg,iz
    integer :: ipoint,ipoint1B,ipoint1E,ipoint1
    integer :: jpoint,jpoint1B,jpoint1E,jpoint1
    integer :: np,ib,IPS,ibeibei,ips1,ip,jp
    integer :: ifunit,imonthEmit,ilay_ems,iapm,igo,kk
    integer :: ifindit,ifindnum
    integer :: NSNDMRK,NPSR
    integer :: ifadsm
    integer :: nspe_sm
    integer :: lx0,ly0,lx1,ly1
    integer :: IXX,IXC
    integer :: iopen,irechgt,km,loop

    include 'apm_parm.inc'
    include 'chm1.inc'
    include 'gas1.inc'
    include 'params1'
    include 'tuv.inc'

    call shr_file_getLogUnit (shrlogunit)
    call shr_file_getLogLevel(shrloglev)
    call shr_file_setLogUnit (iulog)

       call seq_cdata_setptrs(cdata_ge, ID=GEATMID, mpicom=mpicom_atm,&

                              ntasks=numprocs,gsMap=gsMap_ge, dom=dom_ge, infodata=infodata)

if(first_time) then
	    
       if (seq_comm_iamroot(GEATMID)) then
          inquire(file='gea_modelio.nml',exist=exists)
          if (exists) then
             iulog = shr_file_getUnit()
             call shr_file_setIO('gea_modelio.nml',iulog)
          endif
          write(iulog,*) "GEATM initialization"
       endif
       
       print *,'***mpi_communicator_geatm***',mpicom_atm,numprocs

!--------------------------------------------------------------------
!   parameter reading
!--------------------------------------------------------------------   

 naqpms_dir='.'

 OPEN(31,FILE=trim(naqpms_dir)//'/emit/apm-input.dat',form='formatted')
 read(31,*)iyear1,imonth1,idate1,ihour1
 iminute1=0
 read(31,*)nest
 read(31,*) lglbrun
 read(31,*) lgaschemsmp
 if(lgaschemsmp) then
   iopt_gaschem=2
 else
   iopt_gaschem=1
 endif

 read(31,*) lapm   ! shun : flag for apm
 if(lapm) laer=.false.
 if(lgaschemsmp) lapm=.false.
 read(31,*) ctdway ! shun : the way coated mass to be processed
 read(31,*) laqchem
 read(31,*) lnaqpms_pso4
 read(31,*) lnaqpms_ems
 read(31,*) lrd_lai
 
 agtflag='apm3sp'
 if(.not.lapm) then
   agtflag='efolding'
 endif

 if(nest.gt.5)then
   print *,'the maxinum domains are set as five(5),please revise it'
   stop 
 endif

 read(31,*)ntt
 do i=1,nest
 read(31,*)ntbeg(i),ntend(i)
 enddo
 read(31,*) flagadv
 read(31,*)idifvert      ! to select the diffusion shceme 1: local 2: acm2
 read(31,*)ichemgas      ! to select gas chem
 read(31,*)idry      ! to select drydepostion scheme 1: constant 2: calculated
 if(idry.eq.2) then
   ddep_flag='W89'
 elseif(idry.eq.3) then
   ddep_flag='Z03'
 endif

 read(31,*)iglobal       ! to select global conditions
 read(31,*)imodis        ! to set modis landuse(1);0 is USGS landuse
 read(31,*)press         ! to read the height(hpa) of NAQPMS top conditions from global
 read(31,*)hh            ! the top height of naqpms
 read(31,*)nzz
 do ne=1,nest
 read(31,*)nx(ne),ny(ne),nz(ne),nxlo(ne),nylo(ne)
 enddo

 read(31,*) (dtstep_syn(ne),ne=1,nest)  !nhfq_updtmet
 read(31,*) (nhfq_updtmet(ne),ne=1,nest)  !nhfq_updtmet
 read(31,*) (nhfq_output(ne),ne=1,nest)  !nhfq_updtmet
 
 read(31,*) caveoutclab

 read (31,*) ratio       ! to determine the dx and dy resolution ratio between mother and child domian 
 read(31,*) isize        ! to determine the size of aerosols
 read(31,*) iaer         ! to determine the type of aerosols

 allocate(gravel(isize,iaer))

 do iiaer=1,iaer
   read(31,*)(gravel(iisize,iiaer),iisize=1,isize)
 enddo

! LUO (2009)
!  11.348127E-04,43.162551E-04,10.8355374E-03,37.5083238E-03 !Sea Salt Gravel
!  1.8913545E-04,7.1937585E-04,1.8059229E-03,6.2513873E-03 !Dust Gravel
! Wang (1997)
! 4.01E-05, 1.46E-04, 5.34E-04, 1.96E-03 ! DUST Gravel 

 ALLOCATE (MSIZDIS(ISIZE+1),MSIZDID(ISIZE+1)) ! SEA SALT AND DUST PARTICLES SIZE DISTRIBUTION
 READ(31,*) (MSIZDID(IISIZE),IISIZE = 1, ISIZE+1 ) ! DUST
 READ(31,*) (MSIZDIS(IISIZE),IISIZE = 1, ISIZE+1 ) ! SEA
 
 KDUSTTOP = 6 ! DUST CAN TRANSPORTED TO 1KM TOP

 !!!!!!!!!!!!!!!!!!!!!
 ! For Source Mark
 read(31,*)(ifsm(ne),ne=1,nest)    ! if we need Source Mark ?
 ifsmt=0
 do ne=1,nest
    ifsmt=ifsm(ne)+ifsmt
 enddo
 if(ifsmt>0)then
 read(31,*)idmSet,iSrcDefined,ismMax,iHgtLMax
              ! idmSet to define how many species
              ! iSrcDefined to define how many locations
              ! how many sourceis to mark; it should be ismMax=3+IsrcDefined*iHgtLMax
              ! iHgtLMax to define how many types of emissions
 ismMaxHere=3+IsrcDefined*iHgtLMax
 if(ismMax.ne.ismMaxHere)then
        print *, 'ismMax should be equel to 3+IsrcDefined*iHgtLMax'
        print *, ismMax,ismMaxHere
        stop
 endif

 allocate(igMark(idmSet))
 allocate(iaMarkAer(idmSet))
 allocate(iaMarkSiz(idmSet))
                          ! to define how many types of emissions
 allocate(TmpSM(ismMax))
 do idm=1,idmSet
   read(31,*)igMark(idm),iaMarkAer(idm),iaMarkSiz(idm) 
 enddo
                          ! to define how many locations
                          ! how many sourceis to mark
 endif
 close(31)

 CLOSE(999)
 OPEN(999,FILE=trim(naqpms_dir)//'/emit/emitinput.dat')
 READ(999,*)  NEMIT    ! THE NUMBER OF EMISSION SPECIES
 READ(999,*)  NLAY_EM  ! THE TYPE OF EMISSION 
 ALLOCATE(IPIG(NEMIT))
 READ(999,*) (IPIG(I),I=1,NEMIT) ! THE IG OFEMISSIONS SPECE IN MODEL

 allocate( emt2d_zfrc(nzz,NLAY_EM) ); emt2d_zfrc=0
 allocate( cfmode(NLAY_EM) )

 do ictg=1,NLAY_EM
   read(999,*) cfmode(ictg),(emt2d_zfrc(iz,ictg),iz=1,4) ! shun
 enddo

 if(.not.allocated(ratioem1)) then
    allocate( ratioem1(nzz) &
             ,ratioem2(nzz) &
             ,ratioem3(nzz) &
             ,ratioem4(nzz) &
             ,ratioem5(nzz) &
             ,ratioem6(nzz))
 endif

    ! shun emit.sen
    if(lnaqpms_ems) then
      if(myid.eq.0) print*,'lnaqpms_ems=',lnaqpms_ems
      if(.not.allocated(emsfrc)) allocate(emsfrc(NEMIT,NLAY_EM))
      if(.not.allocated(ipig_ems))  allocate(ipig_ems(NEMIT))
      call get_funit(iemsfunit)
      open(iemsfunit,file=trim(naqpms_dir)//'/emit/emsfrc.txt')
      read(iemsfunit,*) emsflag,emsallfrc
      if(emsflag.eq.'all') then
        emsfrc=emsallfrc
      elseif(emsflag.eq.'spc') then
        do idxems=1,NEMIT
          read(iemsfunit,*) ipig_ems(idxems) &
                           ,(emsfrc(idxems,ilay_ems),ilay_ems=1,NLAY_EM)
        enddo
      endif
      close(iemsfunit)
      do idxems=1,NEMIT
          !print*,ipig_ems(idxems),(emsfrc(idxems,ilay_ems),ilay_ems=1,NLAY_EM)
      enddo
    endif
 
  igas = 102
  igasCBM = 74 
  iopen = 1
  iprecise = 1  ! 1 best precise, 2 the second
  ikosaline = 1 ! 1 on-line       2 off-line
  imasskeep = 1 ! 1 to keep mass-keeping

  lprocess=.false.
  iprocess=24   ! number of process analysis 

  time = 0
  NSOA = 6      ! TOTAL NUMBERS OF SOA
  ndustcom =  11 ! dust aerosols compositions numbers
  nseacom = 8  ! sea salt compositions numbers

  !shun@20161227
!  igassmp=5 ! h2so4,h2o2,so2,dms,nh3

!------------------------------------------------------


! shun@20151215
 iedgas=igasCBM

 if(lgaschemsmp) then
   iedgas=igassmp
 endif

 itotalspe=iedgas+iaer*isize
  !!!!!!!!!!!!!!!!!
  ! for Source Mark
  if(ifsmt>0)then
   itotalspe=itotalspe+ismMax*idmSet
   print *,'itotalspe=',itotalspe
  endif
 ! for sea salt and dust composition
   itotalspe = itotalspe + nseacom*isize + ndustcom*isize

!shun@20151214
!===========================================
  if(laerv2) then
    ist_aerom=iedgas+1
    ied_aerom=iedgas+naersp*naerbin
    ntr_aerom=naersp*naerbin
    itotalspe = itotalspe + naersp*naerbin
  endif
!===========================================

 !> itotalspe including apm
  IF(lapm) THEN
    itotalspe = itotalspe + NSO4 + NSEA + NDSTB + NBCOCT + 4 +   1 &
               +nbincb+nbincb
 !                       salfate  seasalt  dust    BCOC coating suferic vapor
  ENDIF
 !<

 isrnum = itotalspe
 
 if(lglbrun) then
   itotalspe=itotalspe+1+1 ! +u+v
 endif

 allocate(atestR(nzz,itotalspe),atestS(nzz,itotalspe))
 allocate(atestR0(itotalspe),atestS0(itotalspe))

 if(lglbrun) then
    ALLOCATE(ATESTR4W(NZZ,1000),ATESTS4W(NZZ,1000))
    ALLOCATE(ATESTR4W0(1000),ATESTS4W0(1000))
  endif

!--------------------------------------------------------------------
!    Initial GEATM VARIABLES
!-------------------------------------------------------------------- 
       call initial_geatm_var
!--------------------------------------------------------------------
!    Initial WRFGRID and CAMGRID
!--------------------------------------------------------------------    
       call initial_wrfgrid(wrfgrid)
       call initial_camgrid(camgrid)
       call init_gea_pio
       
include 'module_main/mpi_domain_split.f90' 

  !-----------------------for cam, added by juanxiong he---------------------------
  cnx(ne)=camgrid%num_camgrid_lon
  cny(ne)=camgrid%num_camgrid_lat
  if(ne.eq.1) then
  call mpe_decomp1d( cnx(ne), dims(1,ne), coords(1,ne), csx(ne), cex(ne) )
  call mpe_decomp1d( cny(ne), dims(2,ne), coords(2,ne), csy(ne), cey(ne) )
  end if
  !-----------------------for CAM, added by Juanxiong He---------------------------       

!--------------------------------------------------------------------
!   Initial AVECT, added by Juanxiong He
!--------------------------------------------------------------------
       ! Initialize MCT gsMap, domain and attribute vectors
       ! initial processors map
       call geatm_SetgsMap_cam(camgrid, mpicom_atm, GEATMID, gsMap_ge ) 
       lsize = mct_gsMap_lsize(gsMap_ge, mpicom_atm)
       ! initial domain       
       call geatm_domain_cam( camgrid, lsize, gsMap_ge, dom_ge ) 
       
       !
       ! Initialize MCT attribute vectors
       !             
        call mct_aVect_init(x2c_c1, rList=seq_flds_x2ge_fields, lsize=lsize) 
        call mct_aVect_zero(x2c_c1)

        call mct_aVect_init(x2c_c2, rList=seq_flds_x2ge_fields, lsize=lsize) 
        call mct_aVect_zero(x2c_c2)

        call mct_aVect_init(c2x_c, rList=seq_flds_ge2x_fields, lsize=lsize)
        call mct_aVect_zero(c2x_c) 

do ne=1,nest
  mem_per_block(ne) = (ex(ne)-sx(ne)+3)*(ey(ne)-sy(ne)+3)
enddo

call allo_naqpms_var(nx,ny,nzz,nest,sx,ex,sy,ey,mem_per_block &
                    ,igas,IAER,ISIZE,ndustcom,nseacom &
                    ,ifsmt,ifsm,idmSet,ismMax,igMark &
                    ,NLAY_EM,lprocess,iprocess,PrintTermGas &
                    ,mem2d,mem3d,mem4d,mem5d,mem2dgas,mem3daer,mem_emt2d )
call allo_met_var(nx,ny,nzz,nest,sx,ex,sy,ey,mem_per_block,lrd_lai)
call allo_grid_var(nx,ny,nzz,nest,sx,ex,sy,ey,mem_per_block) 
call allo_tmpwork_var(nx,ny,nzz,nest,sx,ex,sy,ey,mem_per_block &
                     ,igas,IAER,ISIZE,ndustcom,nseacom &
                     ,ifsmt,ifsm,idmSet,ismMax,igMark &
                     ,imasskeep )
if(lgaschemsmp) then
 call allo_smpchem_var(lgaschemsmp,nx,ny,nzz,nest,sx,ex,sy,ey,mem_per_block)
endif

!============================================================================|
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++|
!> shun : apm memory and location of first element for apm vars in each layer

IF(lapm) THEN ! apm flag

 if(myid.eq.0) print*,'run apm'

 call allo_apm(nx,ny,nzz,nest,ctdway,sx,ex,sy,ey,mem_per_block)

 call get_funit(ifunit)
 open(ifunit,file=trim(naqpms_dir)//'/namelist.apm')
 read(ifunit,apm_lvar)
 read(ifunit,apm_ldyn)
 read(ifunit,apm_sensitivity)
 close(ifunit)
 ls2bcoc=.not.ls2sulf

 call  apm_basic_var(naqpms_dir)

ENDIF ! apm flag
!< end of apm memory allocation
!============================================================================!

call  allo_aqchem(nx,ny,nzz,nest,sx,ex,sy,ey,mem_per_block)

!=============================================================================|

call initialize_naqpms( myid,iyear1,imonth1,idate1,ihour1,iminute1 &
                  ,nest,nzz,nx,ny,nz,sx,ex,sy,ey,ne &
                  ,igas,isize,iaer &
                  ,ndustcom &
                  ,ifsmt,ifsm,idmSet,ismMax,igMark )
if(1==2) then
call wr_naq_init( myid,ntbeg &
                  ,iyear1,imonth1,idate1,ihour1,iminute1 &
                  ,nest,nzz,nx,ny,nz,sx,ex,sy,ey,ne &
                  ,igas,isize,iaer &
                  ,ndustcom &
                  ,ifsm,ifsmt,idmSet,ismMax,igMark )
endif

do ne=1,nest
iitime = (ntbeg(ne)-1)*3600
call getnewdate( iyear1,imonth1,idate1,ihour1,iitime  &
               &,iyear2,imonth2,iday2, ihour2,iminute2 )
call naqpms_tracer_output &
 & ( myid &
 &  ,iyear2,imonth2,iday2,ihour2,iminute2 &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d,tropp &
 &  ,mem3d &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,PrintGas )
enddo

!==============================================================
!> apm initial condition

if(lapm) then
if(myid.eq.0) print*,'Shun : initialize APM'
DO ne=1,nest
  !> shun : initialize apm vars if nessary (lapm=.true.)
  IF(lapm.and.lapm_init) then
    if(.not.lapm_restart) then
      call apm_ic(myid,lapm,ne,nx,ny,nzz,nest,sy,ey,sx,ex,ip3mem)
    else
      if(myid.eq.0) print*,'restart apm'
      call apm_ic(myid,lapm,ne,nx,ny,nzz,nest,sy,ey,sx,ex,ip3mem)
      iitime = (ntbeg(ne)-1)*3600
      call getnewdate( iyear1,imonth1,idate1,ihour1,iitime  &
                     &,iyear2,imonth2,iday2, ihour2,iminute2)
      call apm_rst( myid,lapm,ne,nx,ny,nzz,nest,sy,ey,sx,ex,ip3mem &
                  &,naqpms_dir,iyear2,imonth2,iday2,ihour2 )
    endif
  ENDIF

  !cycle
  !> shun : write apm initial data
 if(lapm.and.lapm_wr00) then
  iitime = (ntbeg(ne)-1)*3600    ! in seconds
  call getnewdate(iyear1,imonth1,idate1,ihour1,iitime, &
                iyear2,imonth2,iday2, ihour2,iminute2)
  call wr_apm_var( myid,lapm &
                  ,iyear2,imonth2,iday2,ihour2,iminute2 &
                  ,nest,nzz,sx,ex,sy,ey,ne &
                  ,ip2mem,ip3mem,mem2d,mem3d &
                  ,u,v,rh1,clw,rnw,RAINCON,RAINNON )
 endif
  !<
if(lapm_dust00)  then
  call keep_dust_zero( myid,lapm,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
endif

call apm_shun_check( myid,lapm,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,ip3mem,mem3d,'apm_ic' )

ENDDO
endif
!< end of apm initial condition
!===================================================================

! read model grid information
call read_gridinfo( myid,nest,sx,ex,sy,ey,nx,ny,nzz )

IF(IMODIS==1) THEN
do ne=1,nest
     i0= ip2mem(ne)
     CALL MODISLAND(myid,land_USE(i0),sx(ne),ex(ne),sy(ne),ey(ne),ne)
enddo
ENDIF

do ne=1,nest
if(myid.eq.0) print*,'dim : ',sx(ne),ex(ne),sy(ne),ey(ne)
enddo

if(lgaschemsmp) then
 call read_monthly_oxidants( myid,nest,sx,ex,sy,ey,nx,ny,nzz )
endif

 first_time=.false.    

else
!---------------------------------------------------------------------------    
!  geat or read the initial data, phase = 2
!---------------------------------------------------------------------------

    !----------------------------------------------------
    ! added by juanxiong he
    !----------------------------------------------------
    open(1000,file='wrfd01.dat',form='unformatted',&
         access='direct',recl=nx(1)*ny(1),status='old')
    irechgt=1
    ! to read SOIL TYPE
    i0=ip2mem(1)
    call read2d(myid,FSOIL(i0),sx(1),ex(1),sy(1),ey(1), &
              nx(1),ny(1),irechgt,1000)

    ! to read VEGETATION FRACTION (%)
    i0=ip2mem(1)
    call read2d(myid,FVEG(i0),sx(1),ex(1),sy(1),ey(1), &
              nx(1),ny(1),irechgt,1000)

    ! read terrain
    i0=ip2mem(1)
    call read2d(myid,HGT1(i0),sx(1),ex(1),sy(1),ey(1), &
              nx(1),ny(1),irechgt,1000)
       do j= sy(1),ey(1)
       do i= sx(1),ex(1)
           km=i0+(ex(1)-sx(1)+3)*(j-sy(1)+1)+i-sx(1)+1
           wrfgrid%ht(i,j)=HGT1(km)*1.0_8   
        end do
       end do
    ! the cubic spline interpolation needs the value varys from the large to the small
    ! Firstly the program reverses the wrfgrid from surface-to-upper to upper-to-surface
    ! for the sake of cubic spline interpolation.
    ! At subroutine wrfgrid_to_geatm, the program will reverse the export of wrfgrid to geatm from
    ! upper-to-surfaceto surface-to-upper.
    do j=1,ny(1)
    do k=1,wrfgrid%num_wrfgrid_levels
    do i=1,nx(1)
       wrfgrid%z3d(i,k,j) = wrfgrid%sigma(wrfgrid%num_wrfgrid_levels-k+1)*(20000.0-wrfgrid%ht(i,j))+wrfgrid%ht(i,j)
    enddo
    enddo
    enddo

    ! read landmask, 1 for land, 0 for sea
    i0=ip2mem(1)
    call read2d(myid,landmask(i0),sx(1),ex(1),sy(1),ey(1), &
              nx(1),ny(1),irechgt,1000)
    close(1000)

    call geatm_import_mct(x2c_c1, camgrid, loop)
    !----------------------------------------------------
    ! added by juanxiong he
    !----------------------------------------------------

 end if      ! first time

    call shr_file_setLogUnit (shrlogunit)
    call shr_file_setLogLevel(shrloglev)   
end subroutine geatm_init_mct

subroutine geatm_run_mct(EClock_aa, EClock, cdata_a, x2c_c1, x2c_c2, c2x_c)
    use geatm_vartype
    use shr_sys_mod, only: shr_sys_flush
    
    include 'mpif.h'
    ! 
    ! Arguments
    !
    type(ESMF_Clock)            ,intent(in)    :: EClock_aa ! cam
    type(ESMF_Clock)            ,intent(in)    :: EClock  ! geatm
    type(seq_cdata)             ,intent(inout) :: cdata_a ! geatm
    type(mct_aVect)             ,intent(inout) :: x2c_c1   ! cam -> cpl -> geatm  
    type(mct_aVect)             ,intent(inout) :: x2c_c2   ! cam -> cpl -> geatm
    type(mct_aVect)             ,intent(inout) :: c2x_c   ! geatm -> cpl -> cam
    
    integer status(mpi_status_size)
    integer :: ymd, tod, curr_ymd, curr_tod, dtime
    integer,save ::it1 =1
    logical :: dosend

    character*40, dimension(102) :: GC_Unit,GC_NAME
    integer :: ifunit95,ifunit96,ifunit97,ifunit98,ifunit99
    integer, dimension(8,200) :: ISNDMRK    
    integer :: ntt,iprocess
    integer :: KDUSTTOP
    integer :: nzz_out,iwritegas
    integer :: numTGRV
    integer :: itt,iPrintTermGas,IPSMARK
    integer :: i,j,k,iisize,iiaer,idm,ig,iemittype
    integer :: ixy,i0,i02,i03,i04,i05,i00,ia,is,ism,ib5,jb5,igg,itsp,iduc,i05c
    integer :: iwb,ieb,jsb,jeb,ne1
    integer :: iaersp,iaerbin,i04aer
    integer :: i059,i0510,i0511,i0512,i0513,i0514,i0515,i0516
    integer :: i03_1,i03p1,i0_1,i04_so2,i04_hno3,i05_1,i05_2
    real :: hh,dt,dt_naqpms,dt_cbmz,dcost
    integer :: iia,ii,iii,ikl,ikk,IR,icpu
    integer :: ictg,iz
    integer :: ipoint,ipoint1B,ipoint1E,ipoint1
    integer :: jpoint,jpoint1B,jpoint1E,jpoint1
    integer :: np,ib,IPS,ibeibei,ips1,ip,jp
    integer :: ifunit,imonthEmit,ilay_ems,iapm,igo,kk
    integer :: ifindit,ifindnum
    integer :: NSNDMRK,NPSR
    integer :: ifadsm
    integer :: nspe_sm
    integer :: lx0,ly0,lx1,ly1
    
    include 'params1'
    include 'tuv.inc'
    include 'apm_parm.inc'
    ! Map input from mct to geatm data structure
    call geatm_import_mct( x2c_c1, camgrid, loop )
    ! get the next coupling time of CAM 
    call seq_timemgr_EClockGetData(EClock_aa, curr_ymd=curr_ymd, curr_tod=curr_tod)
    ! get the next coupling time of GEATM
    call seq_timemgr_EClockGetData(EClock, curr_ymd=ymd, curr_tod=tod, dtime=dtime)
!    print *,'GEATM=',ymd,tod,'CAM=',curr_ymd,curr_tod
    ! get current time of GEATM
    call seq_timemgr_EClockGetData(EClock, prev_ymd=ymd, prev_tod=tod)
    iyear3=ymd/10000
    imonth3=(ymd-ymd/10000*10000)/100
    iday3=ymd-ymd/100*100
    ihour3=tod/3600

    if(mod(ihour3,6).eq.0) then
    call output_atm(iyear3,imonth3,iday3,ihour3,1) ! atm
    end if

    ! to integration for each time step         
    dosend = .false.
    do while (.not. dosend)
!-----------------------------!
! start time integration loop !
!-----------------------------!

 lupdt_met = .true.

 iitime = (it1-1)*3600    ! in seconds
 call getnewdate(iyear1,imonth1,idate1,ihour1,iitime, & 
                iyear2,imonth2,iday2, ihour2,iminute2)
                
    ymd = iyear2*10000 + imonth2*100 + iday2
    tod = ihour2*3600+iminute2*60
    dosend = (seq_timemgr_EClockDateInSync( EClock, ymd, tod))                

if(myid.eq.0) then
print*
write(*,'(a)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
write(*,56789) '% Outer Time Loop, Hour = ',it1 &
    & ,' Time : ',iyear2,'-',imonth2,'-',iday2,'_', ihour2,':',iminute2,' %'
write(*,'(a)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
print*
endif
56789 format(a,i3.3,1x,a,i4.4,a,i2.2,a,i2.2,a,i2.2,a,i2.2,a)

! to read data
loop_nest_rddata : do ne=1,nest ! loop_nest_rddata

  if(it1.ge.ntbeg(ne) .and. it1.le.ntend(ne))then ! time_range_no1

    !> lijie modify to global condition
    if(iglobal==1.and.mod(ihour2,1)==0) then
        ! to read global concentration of no2, o3, co
        call start_timing
        call rd_global_conc( myid,iyear2,imonth2,iday2,ihour2,iminute2 &
                            ,nest,nzz,nx,ny,nz,sx,ex,sy,ey,ne )
        call end_timing('read global no2 o3 co', ne, myid )

    endif  !global
!-------------------------------finish----------------------

!++++++++++++++++++to  read the meteorological field+++++++++++++++
if(mod(it1-1+nhfq_updtmet(ne),nhfq_updtmet(ne)).eq.0) then
   call start_timing
   call rd_met( myid,iyear2,imonth2,iday2,ihour2,iminute2 &
                  ,nest,nzz,nx,ny,nz,sx,ex,sy,ey,ne )
   call cal_dms_emis( myid,iyear2,imonth2,iday2,ihour2,iminute2 &
                     ,nest,nzz,nx,ny,nz,sx,ex,sy,ey,ne,mem2d )
   call end_timing('read met fields', ne, myid )
endif

!--------------------------------------------------------------

  if(ikosaline==2 .and. ne .lt. 2)then   ! to read kosaemit data (40+x)
                                         ! ikosaline == 1 online ; 2 offline
    do k=1,isize
      i0=ip5mem(1,k,2,ne)   !ip5mem(nzz,isize,iaer,nest)
      call read2d(myid,aer_src(i0),sx(ne),ex(ne),sy(ne),ey(ne), &
              nx(ne),ny(ne),irec_as(ne),40+ne)
    enddo

  endif 
!----------------------------------------------------------------

  !zifa 2006/07/13/B
  if(it1.ge.ntbeg(ne).and.it1.le.ntend(ne)) then  !lijie add ! time_range_no2
    
  !!!!!!!!!!!!!!!!!!!!!!!!!!
  ! For Source Mark
  if(it1==ntbeg(ne) .and. ifsm(ne)==1)then  ! to get source/map
    call openfileSrcMap(myid,nx(ne),ny(ne),ne)
    i0=ip2mem(ne)
    call read2dmap(myid,MapSource(i0),sx(ne),ex(ne),sy(ne),ey(ne), &
              nx(ne),ny(ne),110+ne)
  endif 
  !!!!!!!!!!!!!!!!!!!!!!!!!!

  imonthEmit = imonth2

!if(myid.eq.0) print*,'rd_emfl'
call start_timing
call  naqpms_rd_emfl &
 & ( myid &
 &  ,naqpms_dir &
 &  ,iyear2,imonth2,iday2,ihour2 &
 &  ,lnaqpms_ems,lfrac_so2_emit &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,NEMIT,NLAY_EM,IPIG,emsfrc &
 &  ,igas,iaer,isize,nseacom,ndustcom )
call end_timing('read emission',ne,myid)

  endif ! time_range_no2 if block


 ! in outer nest do loop ( read data )

!-----------to find the layer of top conditons from global model and of pbl height----

call start_timing
call cal_trop_pbltop ( myid,ne,nx,ny,nzz,nest,sy,ey,sx,ex,mem2d,ktop,tropp )
call end_timing('trop_pbltop', ne, myid )

!-----------------------------    
if(numprocs .gt. 1 )then
         
 call MPI_BARRIER( LOCAL_COM, ierr )

 do k=1,nzz
   i03=ip3mem(k,ne)
   call exchng2( myid, u(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   call exchng2( myid, v(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
if(1==1) then
   call exchng2( myid, dx(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   call exchng2( myid, dy(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   call exchng2( myid, dz(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   call exchng2( myid, roair3d(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   call exchng2( myid, pzps(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   call exchng2( myid, t(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   call exchng2( myid, Plev(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   i02=ip2mem(ne)
   call exchng2( myid, mpfac(i02), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
endif ! shunkkadv

   if(imasskeep==1)then
     call exchng2( myid, kpmass_m1(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
              comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
              nbrtop(ne), nbrbottom(ne) )
   endif
 enddo

 i02=ip2mem(ne)
 call exchng2( myid, TERRAIN(i02), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )

 call exchng2( myid, LAND_USE(i02), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )


endif

  !!! set boundary winds : no gradient boundary condition

   i02=ip2mem(ne)
   call setwindbound(myid,mpfac(i02),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
   call setwindbound(myid,TERRAIN(i02),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
   call setwindbound(myid,LAND_USE(i02),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))


   do k=1,nzz   ! get boundary

    i03=ip3mem(k,ne)
    call setwindbound(myid,u(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
    call setwindbound(myid,v(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))

if(1==1) then
    call setwindbound(myid,dx(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
    call setwindbound(myid,dy(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
    call setwindbound(myid,dz(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
    call setwindbound(myid,roair3d(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
    call setwindbound(myid,pzps(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
    call setwindbound(myid,t(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
    call setwindbound(myid,Plev(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
endif ! shunkkadv

   enddo

!=================================================================
if(lglbrun) then
  if(ne.eq.1) then

    DO IPS=1,IPOLARNUM

      IF(IPOLARMRK(2,IPS)==MYID) THEN  !!! need to send
        DO K=1,NZZ
          ITSP=0
          I0=IP3MEM(K,NE)
          ITSP=ITSP+1
          CALL GETVALUE(MYID,U(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))
          ITSP=ITSP+1
          CALL GETVALUE(MYID,V(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))
          ITSP=ITSP+1
          CALL GETVALUE(MYID,dx(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))
          ITSP=ITSP+1
          CALL GETVALUE(MYID,dy(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))
          ITSP=ITSP+1
          CALL GETVALUE(MYID,dz(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))
          ITSP=ITSP+1
          CALL GETVALUE(MYID,roair3d(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))
          ITSP=ITSP+1
          CALL GETVALUE(MYID,pzps(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))
          ITSP=ITSP+1
          CALL GETVALUE(MYID,t(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))
          ITSP=ITSP+1
          CALL GETVALUE(MYID,Plev(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))

          I0=ip2mem(ne)
          ITSP=ITSP+1
          CALL GETVALUE(MYID,mpfac(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))
          ITSP=ITSP+1
          CALL GETVALUE(MYID,TERRAIN(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))
          ITSP=ITSP+1
          CALL GETVALUE(MYID,LAND_USE(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(4,IPS),IPOLARMRK(5,IPS),ATESTS4W(K,ITSP))
        ENDDO


        DO K=1,NZZ
          IPSMARK = IPS + 720 + (k-1)*IPOLARNUM
          do ibeibei=1,2
            atestS4W0(ibeibei)=atestS4W(k,ibeibei)
          enddo
          call MPI_Send(atestS4W0,2,MPI_REAL,IPOLARMRK(1,IPS),IPSMARK,comm2d(ne),ierr)
        ENDDO
      ENDIF

      IF(IPOLARMRK(1,IPS)==MYID) THEN  !!! need to receive
        DO K=1,NZZ
          IPSMARK = IPS + 720 + (k-1)*IPOLARNUM
          call MPI_Recv(atestR4W0,2,MPI_REAL,IPOLARMRK(2,IPS),IPSMARK,comm2d(ne),status,ierr)
          do ibeibei=1,2
            atestR4W(k,ibeibei)=atestR4W0(ibeibei)
          enddo
        ENDDO
        IF(IPOLARMRK(5,IPS)==1.OR.IPOLARMRK(5,IPS)==NY(NE)) THEN
          IF(IPOLARMRK(5,IPS)==1) THEN
              IPP=IPOLARMRK(5,IPS)-1
          ELSE
              IPP=IPOLARMRK(5,IPS)+1
          ENDIF
          DO K=1,NZZ
            I0=IP3MEM(K,NE)
            ITSP=0
            ITSP=ITSP+1
            call PUTVALUE(MYID,U(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))
            ITSP=ITSP+1
            call PUTVALUE(MYID,V(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))
            ITSP=ITSP+1
            call PUTVALUE(MYID,dx(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))
            ITSP=ITSP+1
            call PUTVALUE(MYID,dy(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))
            ITSP=ITSP+1
            call PUTVALUE(MYID,dz(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))
            ITSP=ITSP+1
            call PUTVALUE(MYID,roair3d(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))
            ITSP=ITSP+1
            call PUTVALUE(MYID,pzps(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))
            ITSP=ITSP+1
            call PUTVALUE(MYID,t(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))
            ITSP=ITSP+1
            call PUTVALUE(MYID,Plev(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))

            I0=ip2mem(ne)
            ITSP=ITSP+1
            call PUTVALUE(MYID,mpfac(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))
            ITSP=ITSP+1
            call PUTVALUE(MYID,TERRAIN(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))
            ITSP=ITSP+1
            call PUTVALUE(MYID,LAND_USE(I0),SX(NE),EX(NE),SY(NE),EY(NE),IPOLARMRK(3,IPS),IPP,atestR4W(k,ITSP))
          ENDDO
        ENDIF
      ENDIF

   ENDDO ! IPS=1,IPOLARNUM

  endif
endif
!=================================================================
    
! to calculate w
  i02=ip2mem(ne)
  do  k=1,nzz
   i0=ip3mem(k,ne)
   if(k.gt.1)then
    i00=ip3mem(k-1,ne)
   else
    i00=ip3mem(1,ne)
   endif
   call get_w(myid,w(i0),w(i00),u(i0),v(i0),dx(i0),dy(i0),dz(i0), &
            HGT1(i02),hh,sx(ne),ex(ne),sy(ne),ey(ne),k)
  enddo

  call calc_zrates( myid,iyear2,imonth2,iday2,ihour2,iminute2 &
                       ,nest,nzz,nx,ny,nz,sx,ex,sy,ey,ne )

  endif   !! time_range_no1

enddo loop_nest_rddata

! end of reading data block

! in it1_loop

!++++++++++++++++++++++++++++++process analysis++++++++++++++++++++
  if(lprocess) then
    GasTermBal = 0.
    gasOLD = gas
  endif
!++++++++++++++++++++++++++++++process analysis++++++++++++++++++++++

! FOR DUST  emissions , dry and wet deposition rate kg/hr/m2
  DUSTEMISS = 0.0
  DUSTDRY   = 0.0
  DUSTWET   = 0.0
  DUSTGRAV  = 0.0 
  DUSTDRYSO4 = 0.0
  DUSTDRYNO3 = 0.0
  DUSTDRYFeII = 0.0
  DUSTDRYFeIII = 0.0
  DUSTWETSO4 = 0.0
  DUSTWETNO3 = 0.0
  DUSTWETFeII = 0.0
  DUSTWETFeIII = 0.0
  DUSTGRAVSO4 = 0.
  DUSTGRAVNO3=0.0
  DUSTGRAVFEII = 0.0
  DUSTGRAVFEIII =0.0

! FOR SEA SALT EMISSIONS g/m2/hr
  SEAEMISS = 0.0 

dt=1200. ! inseconds = 20 minutes

! start inner time integration loop
cur_year=iyear2
cur_month=imonth2
cur_day=iday2
cur_hour=ihour2
cur_minute=iminute2
cur_second=0

idt_syn=0
if(myid.eq.0) then
 print*,'it1=',it1,idt_syn(1)
endif

loop_time_onehour : do itt=1,int(3600/dt)       ! 12*300=3600sec to read data every 1 hour

 if(itt.ne.1) lupdt_met = .false.

!> shun : current time
 call plus8h( 0,0,int(dt/60.0),0,cur_year,cur_month,cur_day,cur_hour,cur_minute,cur_second )

my_year=cur_year
my_month=cur_month
my_day=cur_day
my_hour=cur_hour
my_minute=cur_minute

call int22char( 'int2char' &
               ,cur_year,cur_month,cur_day,cur_hour,cur_minute,cur_second &
               ,ccyear,ccmonth,ccday,cchour,ccminute,ccsecond,timestr )
if(myid.eq.0.and.1==2) then
  write(*,'(a)') '|====================================|'
  write(*,'(a,a,a)') '| current time : ',timestr,' |'
  write(*,'(a)') '|====================================|'
endif

time(ne) = (it1-1)*12*dt +(itt-1)*dt     ! caculated time
iitime = time(ne)
time1hr12dt=time(ne)
call getnewdate(iyear1,imonth1,idate1,ihour1,iitime, &
                iyear2,imonth2,iday2,ihour2,iminute2 )

! to calculate data
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
loop_nest_calulation : do ne=1,nest    ! for nest

ndt_syn(ne)=3600.0/dtstep_syn(ne)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 if(myid.eq.0.and.1==2) then
   print*
   write(*,'(a,i2.2,a,i2.2,1x,a,a)') 'Inner Time Loop for Domain ',ne,' , itt = ',itt,', ',timestr
   print*
 endif


if(it1.ge.ntbeg(ne) .and. it1.le.ntend(ne))then ! if cal_ne

if(mod(int(time1hr12dt+dtstep_syn(ne)),int(dtstep_syn(ne))).eq.0) then ! synchronous time step
      
idt_syn(ne)=idt_syn(ne)+1
time(ne) = (it1-1)*12*dt + idt_syn(ne)*dtstep_syn(ne)     ! chenxsh@20170210
iitime = time(ne)
call getnewdate(iyear1,imonth1,idate1,ihour1,iitime, &
                iyear2,imonth2,iday2,ihour2,iminute2 )

if(myid.eq.0) then
 print*,' idt_syn=',idt_syn(ne) !,iyear2,imonth2,iday2,ihour2,iminute2
endif

! unit transfer for putemit
!------------for gas--------ppb-->ug/m3-------------------------------

call start_timing

!-----------------------emission--------------------
!!! 1 anthropogenic 2 Power plant 3 biomass burning 4:biogenic
!> : emission vertical distribution factor

! shun
IF(lapm) THEN
if(lapm_0emt) then
 call apm_zero_emit ( myid,lapm,ne,nx,ny,nzz,nest,ip3mem,sx,ex,sy,ey )
endif

call apm_shun_check( myid,lapm &
 &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,ip3mem,mem3d,'apm_zero_emit' )
ENDIF

  !> shun : apm bcoc and sulf emit
   IF(lapm) THEN
    if(lapm_sulf_emit) then
!     if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_bcoc_sulf_emit in domain ',ne
     call apm_bcoc_sulf_emit &
       & ( myid &
       &  ,lapm &
       &  ,ne,nx,ny,nzz,nest,sx,ex,sy,ey &
       &  ,igas &
       &  ,ip3mem &
       &  ,ip4mem &
       &  ,ip2memGas,mem2dgas &
       &  ,NLAY_EM,emt2d_zfrc,cfmode,ip_emit2d,mem_emt2d,emit2d ) 
     call apm_shun_check &
       & ( myid &
       &  ,lapm &
       &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
       &  ,ip3mem,mem3d &
       &  ,'apm_bcoc_sulf_emit' )
    endif
   ENDIF
!< end of apm bcoc and sulf emit

call check_naqpms_tracer( myid,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom,'before_putemit' )

call naqpms_put_emit_v2( myid &
 &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d,mem3d,GC_MOLWT,igas,iaer,isize,nseacom,ndustcom &
 &  ,igasCBM,NLAY_EM,ifsm,idmSet,ismMax,igMark )

call check_naqpms_tracer( myid,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom,'after_putemit' )

!stop  'after emttyp'

 !> in if(it1.ge.ntbeg(ne) .and. it1.le.ntend(ne))  block

! ****   PUT DUST AND SEA SALT EMISSIONS 
! ** SEA SALT EMISSIONS ***

call naqpms_putsalt( myid,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d,mem3d,igas,iaer,isize,nseacom,ndustcom,MSIZDIS )

! ----- TO CALCULATE THE HEIGHT FACTOR FOR DUST EMNISSIONS
! TO CALCULATE THE TOTAL EMISSIONS FACTORS(TOTALDUST) BY SCICHINA D, 2011(4):234-242  
call naqpms_putdust( myid,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d,mem3d,igas,iaer,isize,nseacom,ndustcom,KDUSTTOP,IMONTH2,SFT,ITT)

 !> shun : apm salt emit
 IF(lapm) then
  if(lapm_salt_emit) then
   i02  = ip2mem(ne)
!   if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_salt_emit in domain ',ne
   call apm_salt_emit &
     & ( myid &
     &  ,lapm &
     &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
     &  ,iwb,ieb,jsb,jeb &
     &  ,land_use,u10,v10 &
     &  ,ip2mem,mem2d &
     &  ,ip3mem,mem3d )
   call apm_shun_check &
     & ( myid &
     &  ,lapm &
     &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
     &  ,ip3mem,mem3d &
     &  ,'apm_salt_emit' )
  endif
 ENDIF
 !< end of apm salt emit


!> shun : apm dust emit
! dust_emit : ug/(m2 s)
 IF(lapm) THEN
  if(lapm_dust_emit) then
!   if(myid.eq.0) print*,'get dust emit'
  call apm_dust_emit &
     & ( myid &
     &  ,lapm &
     &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
     &  ,ip2mem,mem2d &
     &  ,ip3mem,mem3d &
     &  ,FICE,FSNOW,LAND_USE,FSOIL,FVEG,UST &
     &  ,SOILT,SOILRH &
     &  ,T2,RHSFC,U10,V10 &
     &  ,KDUSTTOP &
     &  ,DUSTHGTF &
     &  ,Z0,UST0 )

   call apm_shun_check &
     & ( myid &
     &  ,lapm &
     &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
     &  ,ip3mem,mem3d &
     &  ,'apm_dust_emit' )
  endif
 ENDIF
!< end of apm dust emit


!> shun : put apm emit
 IF(lapm) THEN
  if(lapm_emit) then
!   if(myid.eq.0)  write(*,'(a,i2.2)') 'call put_apm_emit in domain ',ne
    call put_apm_emit &
     & ( myid &
     &  ,lapm &
     &  ,dtstep_syn(ne),ne &
     &  ,nx,ny,nzz,nest,sx,ex,sy,ey &
     &  ,dz &
     &  ,ip3mem,mem3d )
!< end of put apm emit

if(lapm_dust00)  then
 call keep_dust_zero ( myid,lapm,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
endif

call apm_shun_check( myid,lapm,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,ip3mem,mem3d,'apm_put_emit' )
endif
ENDIF
!< end of put apm emit
!==========================

!------------------------------test for nuclear -----------
if(ne==8)then
! ------------------- put emission -----------
 do k=1,2
    i03=ip3mem(k,ne)
    do ia=1,1  ! for nuclear aerosols
    do is=1,isize
    i05   = ip5mem(k,is,ia,ne)

       do j=sy(ne),ey(ne)
       do i=sx(ne),ex(ne)
       ixy = (ex(ne)-sx(ne)+3)*(j -sy(ne)+1)+i-sx(ne)+1
         if(i==20 .and. j == 20 )aer(i05+ixy)=aer(i05+ixy) + 1. 
       enddo
       enddo
    enddo
    enddo
  enddo
!--------------------- life time ------------------
 dcost = -log(0.001)/(72*3600.)   ! assume 72 hours life time
 do j = sy(ne),ey(ne)
 do i = sx(ne),ex(ne)
      ixy = (ex(ne)-sx(ne)+3)*(j -sy(ne)+1)+i-sx(ne)+1
  do k=1,nzz
    do ia=1,1  ! for nuclear aerosols
    do is=1,isize
        i05   = ip5mem(k,is,ia,ne)
        aer(i05+ixy)=aer(i05+ixy)*exp(-1.*dt*dcost)
    enddo
    enddo
  enddo
 enddo
 enddo
endif

call end_timing('add emission', ne, myid )

!--------------------------to get boundary conditions--------------------
  if(ne==8)then
   ne1=ne+1
   do k=1,nzz   ! get boundary 
     do ia=1,iaer ! for aerosols
     do is=1,isize
       i05=ip5mem(k,is,ia,ne)
       ib5=ib5mem(k,is,ia,ne1)
       jb5=jb5mem(k,is,ia,ne1)
       call getboundnorth(myid,aer(i05),sx(ne),ex(ne),sy(ne),ey(ne), &
              nx(ne),ny(ne),sx(ne1),ex(ne1),sy(ne1),ey(ne1), &
              nx(ne1),ny(ne1),nxlo(ne1),nylo(ne1),aerbdynorth(ib5))
     enddo
     enddo
   enddo
  endif

! shun : gas_unit_ppb

if(.not.lglbrun) then

  if(ne == 1 ) then    ! Zifa tested in AS,Dec 27,2003
!-----------------for global ---------------------------------------
   do k=1,nzz   ! get boundary

    i03=ip3mem(k,ne)
    call setwindbound(myid,globalo3(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
    call setwindbound(myid,globalco(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))
    call setwindbound(myid,globalno2(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne))

   enddo

   IF(iglobal==1) THEN  !from global model
    do k=1,nzz   ! get boundary
      do ig=11,11 ! ozone
       i04=ip4mem(k,ig,ne)
       i0=ip3mem(k,ne)
       call getboundnorth1(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,globalo3(i0))
       call getboundsouth(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,globalo3(i0))
       call getboundeast(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                        nx(ne),ny(ne), ig,globalo3(i0))
       call getboundwest(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,globalo3(i0))
      enddo    !ig
      do ig=17,17 ! CO
       i04=ip4mem(k,ig,ne)
       i0=ip3mem(k,ne)
       call getboundnorth1(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,globalco(i0))
       call getboundsouth(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,globalco(i0))
       call getboundeast(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                        nx(ne),ny(ne), ig,globalco(i0))
       call getboundwest(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,globalco(i0))
      enddo    !ig

      do ig=6,6 ! NO2
       i04=ip4mem(k,ig,ne)
       i0=ip3mem(k,ne)
       call getboundnorth1(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,globalno2(i0))
       call getboundsouth(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,globalno2(i0))
       call getboundeast(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                        nx(ne),ny(ne), ig,globalno2(i0))
       call getboundwest(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,globalno2(i0))
      enddo    !ig
   enddo!k

  ELSE  IF(iglobal==2) then  !fix
!-------------------------------------------------------------------

   do k=1,nzz   ! get boundary 
     do ig=11,11 ! ozone
       i04=ip4mem(k,ig,ne)
       call setboundnorth(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,45.+float(k)*1.5)
       call setboundsouth(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,20.+float(k)*0.8)
       call setboundeast(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                        nx(ne),ny(ne),ig,25.+float(k)*0.8)
       call setboundwest(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,40.+float(k)*1.5,k)
      enddo    !ig
      do ig=17,17 ! co
       i04=ip4mem(k,ig,ne)
       call setboundnorth(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,150.-float(k)*5.)
       call setboundsouth(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,100.-float(k)*5.)
       call setboundeast(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                        nx(ne),ny(ne),ig,200.-float(k)*10.)
       call setboundwest(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),ig,100.-float(k)*5.,k)
      enddo !ig co

  enddo   !k

 endif ! iglobal

call check_naqpms_tracer( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom,'after_4bdy' )

 !> shun : apm boundary condition
 IF(lapm) THEN
  if(lapm_4bdy) then
!   if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_4bdy in domain ',ne
   call apm_4bdy(myid,lapm,ne,nx,ny,nzz,nest,sy,ey,sx,ex,ip3mem) 

   if(lapm_dust00)  then
    call keep_dust_zero( myid,lapm,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
   endif
  endif
 ENDIF
 !< end of apm boundary condition

ENDIF ! if ne=1

endif ! not lglbrun

if(lapm) then
call apm_shun_check( myid,lapm,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,ip3mem,mem3d,'apm_4bdy' )
endif

 !> shun : apm top boundary condition
 if(ne==1.or.ne==2.or.ne==3.or.ne==4) then
  IF(lapm) then
   if(lapm_tbdy) then
!     if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_tbdy in domain ',ne
     call apm_tbdy(myid,lapm,ne,nx,ny,nzz,nest,sy,ey,sx,ex,ip3mem)
   endif

   if(lapm_dust00)  then
    call keep_dust_zero( myid,lapm,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
   endif

   call apm_shun_check &
     & ( myid &
     &  ,lapm &
     &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
     &  ,ip3mem,mem3d &
     &  ,'apm_tbdy' )
 
  ENDIF
 endif
 !< end of apm top boundary condition

!============================set top boundary by li 05-04-21 ==================
!--------------------------------global ------------------------------------
  IF(iglobal==1) THEN
   if(ne==1.or.ne==2.or.ne==3.or.ne==4) then
      do k=nzz,nzz
       do ig=11,11 !Ozone
        i04=ip4mem(k,ig,ne)
        if(k==nzz) then  ! for define the top layer
         i03=ip3mem(k,ne)
         i0=ip3mem(k,ne)
         i02=ip2mem(ne) 
          call setboundtop(myid,ig,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                           nx(ne),ny(ne),globalo3(i0),ne,k,ktop(i02))
        endif   ! to define the top layer
       enddo      
      enddo


      do k=nzz,nzz
       do ig=17,17 !CO
        i04=ip4mem(k,ig,ne)
        if(k==nzz) then
         i03=ip3mem(k,ne)
         i0=ip3mem(k,ne)
         i02=ip2mem(ne)
         call setboundtop(myid,ig,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                           nx(ne),ny(ne),globalco(i0),ne,k,ktop(i02))
        endif
       enddo
      enddo

      do k=nzz,nzz
       do ig=6,6 !no2
        i04=ip4mem(k,ig,ne)
        if(k==nzz) then
         i03=ip3mem(k,ne)
         i0=ip3mem(k,ne)
         i02=ip2mem(ne)
          call setboundtop(myid,ig,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                           nx(ne),ny(ne),globalno2(i0),ne,k,ktop(i02))
        endif
       enddo
      enddo
      
    endif
  ELSE
!-------------------------------finish--------------------------------------
    if(ne==1.or.ne==2.or.ne==3.or.ne==4) then
      do k=nzz,nzz
       do ig=11,11
        i04=ip4mem(k,ig,ne)
         i03=ip3mem(k,ne)
         i0=ip2mem(ne)
         i02=ip2mem(ne)
         ! topo3=0.0 shun@naqpms_varlist
          call setboundtop1(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
                           nx(ne),ny(ne),topo3(i0),ne,k,ktop(i02))
       enddo
      enddo
    endif
ENDIF
!==============================================================================
  if(ne == 8 ) then   
   do k=1,nzz   ! get boundary 
     do ig=1,igas 
       i04=ip4mem(k,ig,ne)
  !     call setboundary(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
  !                       nx(ne),ny(ne))
     enddo    !ig

   !    aerbdynorth = 300.
     aerbdysouth = 100.
     aerbdyeast = 100.
     aerbdywest = 100.
     do ia=1,iaer ! for aerosols
     do is=1,isize
       i05=ip5mem(k,is,ia,ne)

       ib5=ib5mem(k,is,ia,ne)
       jb5=jb5mem(k,is,ia,ne)

       call setboundnorth(myid,aer(i05),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),aerbdynorth(ib5))
       call setboundsouth(myid,aer(i05),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),aerbdysouth(ib5))
       call setboundeast(myid,aer(i05),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),aerbdyeast(jb5))
       call setboundwest(myid,aer(i05),sx(ne),ex(ne),sy(ne),ey(ne), &
                         nx(ne),ny(ne),aerbdywest(jb5))
     enddo        !isize
     enddo        !iaer
   enddo  
  endif

 if(imasskeep==1)then
   do k=1,nzz   ! get boundary 
    i03=ip3mem(k,ne)
    call setboundnorthkpm(myid,kpmass_m1(i03),sx(ne),ex(ne), &
                         sy(ne),ey(ne), nx(ne),ny(ne),1000.)
    call setboundsouthkpm(myid,kpmass_m1(i03),sx(ne),ex(ne), &
                         sy(ne),ey(ne), nx(ne),ny(ne),1000.)
    call setboundeastkpm(myid,kpmass_m1(i03),sx(ne),ex(ne), &
                         sy(ne),ey(ne), nx(ne),ny(ne),1000.)
    call setboundwestkpm(myid,kpmass_m1(i03),sx(ne),ex(ne), &
                         sy(ne),ey(ne), nx(ne),ny(ne),1000.)
    enddo
  endif


call check_naqpms_tracer &
 & ( myid,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom,'after_tbdy' )


!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
   do k=1,nzz
       do ig=1,iPrintTermGas    ! for gas phase
           igg=IGGPOS(ig)
           i04=ip4mem(k,igg,ne)
           i05=ipGasTermBal(k,1,ig,ne) ! 1, emit
           call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05), &
            k,sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dt)
       enddo
   enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++

!=====================================================================
!====    to write boundary conditions into next Domain           =====
!=====================================================================


! shun : gas_unit_ppb
time(ne) = (it1-1)*12*dt + idt_syn(ne)*dtstep_syn(ne)     ! chenxsh@20170210
iitime = time(ne)

!> in inner time integration and nest loop

IF(NE.LE.NEST-1 .and. mod(iitime,int(dtstep_syn(ne))) == 0)THEN ! chenxsh@20170210

!!!!!!-----------------------!!!!!
  
  !> shun : mpi_related

  ! following points need to be sent to other CPU
  !                  need to be got from other CPU
  DO IPS=1,NPSR

  if(IISCPU(IPS)==myid .and. ne==IsNest(IPS))then   ! need to send
        i=IsLocX(IPS)
        j=IsLocY(IPS)
     do k=1,nzz
        itsp=0
        ! for gas speceis
        do ig=1,iedgas
          itsp=itsp+1
          i04 = ip4mem(k,ig,ne)
     call getvalue(myid,gas(i04),sx(ne),ex(ne),sy(ne),ey(ne), &
              i,j,atestS(k,itsp))
        enddo

        ! for aerosols
        do ia=1,iaer
        do is=1,isize
           i05= ip5mem(k,is,ia,ne)
           itsp=itsp+1
     call getvalue(myid,aer(i05),sx(ne),ex(ne),sy(ne),ey(ne), &
              i,j,atestS(k,itsp))
         enddo
         enddo

         !!!!!!!!!!!!!!!!!!!!
         ! for Source Mark
        if(ifsmt>0)then    ! checking 
         do idm=1,idmSet
         do ism=1,ismMax
            i0=ipSMmem(k,ism,idm,ne)
            itsp=itsp+1
      call getvalue(myid,SourceMark(i0),sx(ne),ex(ne),sy(ne),ey(ne), &
              i,j,atestS(k,itsp))
         enddo
         enddo
        endif
         !!!!!!!!!!!!!!!!!!!!

        ! for dust and sea salt composition
        do iduc = 1, nseacom
        do is =1 , isize
          i05c=ip5memcs(k,is,iduc,ne)
          itsp = itsp + 1
     call getvalue(myid, seacomp(i05c),sx(ne),ex(ne),sy(ne),ey(ne), &
             i,j,atestS(k,itsp))
        enddo
        enddo

        do iduc = 1, ndustcom
        do is =1 , isize
          i05c=ip5memc(k,is,iduc,ne)
          itsp = itsp + 1
     call getvalue(myid, dustcomp(i05c) ,sx(ne),ex(ne),sy(ne),ey(ne), &
             i,j,atestS(k,itsp))
        enddo
        enddo

        if(laerv2) then
          include 'aerv2_send_bdy.inc'
        endif

        !> shun : for apm tracers
        IF(lapm) THEN
          include 'apm_send_bdy.inc'
        ENDIF
        !<

!===================================================
        ! for u,v,by chenhs
if(lglbrun) then
        i03= ip3mem(k,ne)
        itsp=itsp+1
     call getvalue(myid,u(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
              i,j,atestS(k,itsp))
        itsp=itsp+1
     call getvalue(myid,v(i03),sx(ne),ex(ne),sy(ne),ey(ne), &
              i,j,atestS(k,itsp))
endif
!====================================================

     enddo !k,1,nzz

     do k=1,nzz
       IPSMARK = IPS + 4000 + (k-1) * NPSR
       do ibeibei=1,isrnum
        atestS0(ibeibei)=atestS(k,ibeibei)
       enddo
       if(myid .ne. IIRCPU(IPS)) then ! pgi
        call MPI_Send(atestS0,isrnum,MPI_REAL,IIRCPU(IPS),IPSMARK,comm2d(ne),ierr)
       endif ! pgi
     enddo 

  endif ! need to send

  if(IIRCPU(IPS)==myid .and. ne == IsNest(IPS) )then   ! need to receive

    do k=1,nzz
      IPSMARK = IPS + 4000 + (k-1) * NPSR
      if(myid .ne. IISCPU(IPS)) then ! pgi
        call MPI_Recv(atestR0,isrnum,MPI_REAL,IISCPU(IPS),IPSMARK,  &
                  comm2d(ne),status,ierr)
        do ibeibei=1,isrnum
           atestR(k,ibeibei)=atestR0(ibeibei)
        enddo
      else
        do ibeibei=1,isrnum
           atestR(k,ibeibei)=atestS(k,ibeibei)
        enddo
      endif ! pgi
    enddo

    i=IrLocX(IPS)
    j=IrLocY(IPS)

    do k=1,nzz

       ips1 = 0
       if(j==0 .or. j==(ny(ne+1)+1))then
         do ip=i,i
           do ig=1,iedgas
              ips1 = ips1 + 1
              i04 = ip4mem(k,ig,ne+1)
     call putvalue(myid,gas(i04),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
              ip,j,atestR(k,ips1))
           enddo

           do ia=1,iaer
           do is=1,isize
              ips1 = ips1 + 1 
              i05= ip5mem(k,is,ia,ne+1)
     call putvalue(myid,aer(i05),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
              ip,j,atestR(k,ips1))
           enddo
           enddo

           !!!!!!!!!!!!!!!!!
           ! for Source Mark
           if(ifsmt>0 )then   !checking
             do idm=1,idmSet
             do ism=1,ismMax
               ips1 = ips1 + 1 
               i0=ipSMmem(k,ism,idm,ne+1)
     call putvalue(myid,SourceMark(i0),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
               ip,j,atestR(k,ips1))
             enddo
             enddo
           endif
           !!!!!!!!!!!!!!!!!!!!

           ! for sea salt and dust compositions
           do iduc = 1, nseacom
           do is = 1, isize
             ips1 = ips1 + 1 
             i05c  = ip5memcs(k,is,iduc,ne+1)
     call putvalue(myid,seacomp(i05c),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
               ip,j,atestR(k,ips1))        
           enddo
           enddo

           do iduc = 1, ndustcom
           do is = 1, isize
             ips1 = ips1 + 1
             i05c  = ip5memc(k,is,iduc,ne+1)
     call putvalue(myid,dustcomp(i05c),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
               ip,j,atestR(k,ips1))
           enddo
           enddo

           if(laerv2) then
             include 'aerv2_receive_ip.inc'
           endif

           !> shun : apm receive ip
           IF(lapm) THEN
            include 'apm_receive_ip.inc'
           ENDIF
           !< end of apm receive ip

!===================================================================================
if(lglbrun) then
           !!! for u,v,by chenhs
           ips1 = ips1 + 1
           i03 = ip3mem(k,ne)
     call putvalue(myid,u(i03),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
              ip,j,atestR(k,ips1))
           ips1 = ips1 + 1
     call putvalue(myid,v(i03),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
              ip,j,atestR(k,ips1))
endif
!===================================================================================

         enddo ! ip
       endif

       ! in k loop
       ips1 = 0 
       if(i==0 .or. i==(nx(ne+1)+1))then
        do jp=j,j
           do ig=1,iedgas
              ips1 = ips1 + 1
              i04 = ip4mem(k,ig,ne+1)
     call putvalue(myid,gas(i04),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
              i,jp,atestR(k,ips1))
           enddo
           
           do ia=1,iaer
           do is=1,isize
              ips1 = ips1 + 1
              i05= ip5mem(k,is,ia,ne+1)
     call putvalue(myid,aer(i05),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
              i,jp,atestR(k,ips1))
           enddo
           enddo
           !!!!!!!!!!!!!!!!!
           ! for Source Mark
           if(ifsm(ne)==1)then
             do idm=1,idmSet
             do ism=1,ismMax
               ips1 = ips1 + 1
               i0=ipSMmem(k,ism,idm,ne+1)
     call putvalue(myid,SourceMark(i0),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
               i,jp,atestR(k,ips1))
             enddo
             enddo
           endif
           !!!!!!!!!!!!!!!!!

           ! for sea salt and dust compositions
           do iduc = 1, nseacom
           do is = 1, isize
             ips1 =  ips1 + 1
             i05c= ip5memcs(k,is,iduc,ne+1) 
     call putvalue(myid,seacomp(i05c),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
              i,jp,atestR(k,ips1))
           enddo
           enddo

           do iduc = 1, ndustcom
           do is = 1, isize
             ips1 =  ips1 + 1
             i05c= ip5memc(k,is,iduc,ne+1)
     call putvalue(myid,dustcomp(i05c),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
              i,jp,atestR(k,ips1))
           enddo
           enddo

           if(laerv2) then
             include 'aerv2_receive_jp.inc'
           endif

           !> shun : apm receive jp
           IF(lapm) THEN
            include 'apm_receive_jp.inc'
           ENDIF
           !<
!======================================================================
           !!! for u,v,by chenhs
if(lglbrun) then
        ips1 = ips1 + 1
        i03 = ip3mem(k,ne)
     call putvalue(myid,u(i03),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
              i,jp,atestR(k,ips1))
        ips1 = ips1 + 1
     call putvalue(myid,v(i03),sx(ne+1),ex(ne+1),sy(ne+1),ey(ne+1), &
              i,jp,atestR(k,ips1))
endif
!======================================================================

        enddo ! jp
      endif ! i

    enddo ! k

  endif ! need to receive

  ENDDO ! IPS

ENDIF ! IF(NE
!==== mpi_related

! in inner time integration and nest loop
time(ne) = (it1-1)*12*dt + idt_syn(ne)*dtstep_syn(ne)     ! chenxsh@20170210

!--------------------------advection & Diffution-------------
    
!=========================================================================

  if(imasskeep==1)then
    kpmass_m1= 1000.  ! Zifa 2004/09/02
    i02=ip2mem(ne)
    do k=1,nzz-1   ! advection
      i03=ip3mem(k,ne)
      ! for mass keeping Zifa 2004/09/02
      call  adv_hori(myid,kpmass_m1(i03),u(i03),v(i03),dx(i03),dy(i03),&
             sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dtstep_syn(ne))
      ! to get mass conservation ratio/error
      call  GetMassRatio(myid,kpmass_m1(i03),RatioMass(i03), &
                  sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne))
    enddo 
  endif

call check_naqpms_tracer( myid,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom,'before_3d_adv' )

call start_timing
call naqpms_3d_adv( myid,imasskeep &
 &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,GC_MOLWT,mem3d,RatioMass,mem2d,ktop &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,ifsm,idmSet,ismMax,igMark,hh )
call end_timing('naqpms_3d_adv',ne,myid)

call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'after_3d_adv' )

call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'before_hadv' )


! horizontal advection
!if(myid.eq.0) write(*,'(a,i2.2)') 'call naqpms_h_adv in domain ',ne

if(1==2) then
call start_timing
call naqpms_h_adv &
 & ( myid &
 &  ,imasskeep &
 &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem3d,RatioMass &
 &  ,mem2d,ktop &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,ifsm,idmSet,ismMax,igMark )
call end_timing('naqpms_h_adv',ne,myid)
call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'after_hadv' )
endif

!--------------------------------------
!> shun : apm horizontal advection
!--------------------------------------
IF(lapm) THEN ! apm flag

call start_timing
call  apm_3d_adv &
 & ( myid &
 &  ,imasskeep &
 &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,GC_MOLWT &
 &  ,mem3d,RatioMass &
 &  ,mem2d,ktop &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,ifsm,idmSet,ismMax,igMark &
 &  ,hh )
 call apm_shun_check &
  & ( myid &
  &  ,lapm &
  &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,'apm_3d_adv' )
call end_timing('apm_3d_adv', ne, myid )

if(1==2) then
call start_timing
if(lapm_hadv) then
! if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_h_adv in domain ',ne
 call apm_h_adv &
 & ( myid &
 &  ,lapm,imasskeep &
 &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,dx,dy &
 &  ,u,v &
 &  ,ip3mem,mem3d,RatioMass )

 if(lapm_dust00)  then
  call keep_dust_zero &
   & ( myid &
   &  ,lapm &
   &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
 endif

 call apm_shun_check &
  & ( myid &
  &  ,lapm &
  &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,'apm_h_adv' )
endif
call end_timing('apm_h_adv', ne, myid )
endif

ENDIF
!--------------------------------------
!< shun end of apm horizontal advection
!--------------------------------------

!> end of horizontal advection

!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
     do k=1,nzz
         do ig=1,iPrintTermGas    ! for gas phase
    igg=IGGPOS(ig)
    i03=ip3mem(k,ne)
    i04=ip4mem(k,igg,ne)
    i05=ipGasTermBal(k,2,ig,ne)    !2--> adv hor
    i059= ipGasTermBal(k,9,ig,ne)  !10-->north input
    i0510=ipGasTermBal(k,10,ig,ne) !11-->south input
    i0511=ipGasTermBal(k,11,ig,ne) !12-->west input
    i0512=ipGasTermBal(k,12,ig,ne) !13-->east input
    i0513=ipGasTermBal(k,13,ig,ne) !14-->west output
    i0514=ipGasTermBal(k,14,ig,ne) !15-->east output
    i0515=ipGasTermBal(k,15,ig,ne) !16-->south output
    i0516=ipGasTermBal(k,16,ig,ne) !17-->north output
   call termballi(myid,gasOLD(i04),gas(i04),GasTermBal(i059),GasTermBal(i0510),&
                  GasTermBal(i0511),GasTermBal(i0512),GasTermBal(i0513),&
                  GasTermBal(i0514),GasTermBal(i0515),&
                  GasTermBal(i0516),u(i03),v(i03),k,dx(i03),sx(ne),ex(ne),sy(ne),ey(ne),&
                  nx(ne),ny(ne),dt)
   call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05),&
                  k,sx(ne),ex(ne),sy(ne), ey(ne),nx(ne),ny(ne),dt)
           enddo
     enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
                                                     

!!!!!!!!!!!!!!!!
 iwb=sx(ne)-1;ieb=ex(ne)+1
 jsb=sy(ne)-1;jeb=ey(ne)+1
 allocate(ww(iwb:ieb,jsb:jeb,nzz),conc(iwb:ieb,jsb:jeb,nzz),&
          uu(iwb:ieb,jsb:jeb,nzz),vv(iwb:ieb,jsb:jeb,nzz),&
          ddx(iwb:ieb,jsb:jeb,nzz),ddz(iwb:ieb,jsb:jeb,nzz),&
          kktop(iwb:ieb,jsb:jeb),concmark(iwb:ieb,jsb:jeb,nzz))

!!!!!!!!!!!!!!!!

  if(imasskeep==1)then
   kpmass_m1= 1000.  ! Zifa 2004/09/02
   i02=ip2mem(ne)
   do k=1,nzz-1   ! advection
    if(k.gt.1)then
       i03_1=ip3mem(k-1,ne)
    else
       i03_1=ip3mem(1,ne)
    endif
    i03=ip3mem(k,ne)
    i03p1=ip3mem(k+1,ne)
    i02=ip2mem(ne)
!      call adv_vert( myid, kpmass_m1(i03_1),kpmass_m1(i03),  &
!                     kpmass_m1(i03p1),  &
!                     w(i03_1),w(i03),w(i03p1),dz(i03_1),dz(i03),dz(i03p1), &
!                     sx(ne), ex(ne), sy(ne), ey(ne) ,k, dt,ktop(i02))
   enddo

   do k=1,nzz-1
    i03=ip3mem(k,ne)
    ! to get mass conservation ratio/error
    call  GetMassRatio(myid,kpmass_m1(i03),RatioMass(i03), &
                 sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne))
   enddo
  endif

deallocate(uu,vv,ww,ddz,ddx,conc,concmark,kktop)


!> vertical advection

!  vertical advection code is coded for each species 
! shun : gas_unit_ppb

 nstep=1

 do j = sy(ne),ey(ne)
 do i = sx(ne),ex(ne)
    ixy = (ex(ne)-sx(ne)+3)*(j -sy(ne)+1)+i-sx(ne)+1
    do k=1,nzz
      i02=ip3mem(k,ne)
      nstep0(i,j)=1.+dtstep_syn(ne)/min(1000., dz(i02+ixy)/(1.E-09+w(i02+ixy)))
      if(nstep<=nstep0(i,j)) nstep=nstep0(i,j)
    enddo
 enddo
 enddo

!if(myid.eq.0) print*,'main-nstep=',nstep

call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'before_vadv' )

!if(myid.eq.0) write(*,'(a,i2.2)') 'call naqpms_v_adv in domain ',ne

if(1==2) then
call start_timing
call naqpms_v_adv &
 & ( myid &
 &  ,imasskeep &
 &  ,ne,dtstep_syn(ne),nstep &
 &  ,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,ktop &
 &  ,mem2d &
 &  ,mem3d &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,ifsm,idmSet,ismMax,igMark )
call end_timing('naqpms_v_adv', ne, myid )

call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'after_vadv' )
endif

!=================================
!> shun : apm vertical advection
IF(lapm) THEN

if(1==2) then
call start_timing
if(lapm_vadv) then
! if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_v_adv in domain ',ne
 call apm_v_adv &
 & ( myid &
 &  ,lapm,imasskeep &
 &  ,ne,dtstep_syn(ne),nstep &
 &  ,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,dx,dy,dz &
 &  ,u,v,w &
 &  ,ktop &
 &  ,ip2mem,mem2d &
 &  ,ip3mem,mem3d ) 

 if(lapm_dust00)  then
  call keep_dust_zero &
    & ( myid &
    &  ,lapm &
    &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
 endif

 call apm_shun_check &
  & ( myid &
  &  ,lapm &
  &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,'apm_v_adv' )
endif
call end_timing('apm_v_adv', ne, myid )

endif

ENDIF
!< end of apm vertical advection
!================================

! end of vertical advection

!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
    do k=1,nzz
        do ig=1,iPrintTermGas    ! for gas phase
           igg=IGGPOS(ig)
           i04=ip4mem(k,igg,ne)
           i05=ipGasTermBal(k,3,ig,ne) ! 3--> vert adv
    call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05), &
           k,sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dt)
        enddo
    enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++

!----------------------cloud and convection-------------------------
! convective cloud lifetimie is 1 hour
! 1200 seconds,unalterable,sensitivity to results
! conduct calculation every two inner time steps , i.e. 10 minutes(600 seconds) 

IF((itt ==1 .or.itt ==3.or. itt == 5 .or.itt ==7.or.itt==9.or.itt==11).and..false.) THEN
!FTRA1 is net, FTRA1D is downdraft, FTRA1U is updraft, 
!FTRA1O is the export form the cell, FTRA1E is enchange of environment 

!if(myid.eq.0) write(*,'(a,i2.2)') 'call naqpms_ccld in domain ',ne
call start_timing
call naqpms_cld_convect &
 & ( myid &
 &  ,ne &
 &  ,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d,ktop &
 &  ,mem3d &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,ifsm,ifsmt,idmSet,ismMax,igMark )
call end_timing('naqpms_cld_convect', ne, myid )


!=========================================
!> shun : apm cloud convection
IF(lapm) THEN
call start_timing 
if(lapm_ccld) then
! if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_ccld in domain ',ne
 call apm_cld_convect &
  & ( myid & 
  &  ,lapm &
  &  ,ne &
  &  ,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,u,v,t,QVAPOR,rh1,Plev,PSFC &
  &  ,ip2mem,mem2d &
  &  ,ip3mem,mem3d )


 if(lapm_dust00)  then
  call keep_dust_zero &
    & ( myid &
    &  ,lapm &
    &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
 endif
 call apm_shun_check &
  & ( myid &
  &  ,lapm &
  &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,'apm_cld_convect' )
endif
call end_timing('apm_cld_convect', ne, myid )
ENDIF
!< end of apm cloud convection
!=========================================

ENDIF 

!> end of convective cloud transport


!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
  do k=1,nzz
   do ig=1,iPrintTermGas    ! for gas phase
    i04=ip4mem(k,igg,ne)
    i05=ipGasTermBal(k,21,ig,ne) ! 21--> moist convect
    call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05), &
      k,sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dt)
   enddo
  enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++  

!>  horizontal  diffusion

!=========================================
!> shun apm horizontal  diffusion
IF(lapm) THEN
call start_timing
if(lapm_hdif) then
!  if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_h_dif in domain ',ne
  call apm_h_dif &
   & ( myid &
   &  ,lapm &
   &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
   &  ,dx,dy &
   &  ,kh &
   &  ,ip2mem,mem2d &
   &  ,ktop &
   &  ,ip3mem,mem3d )

 if(lapm_dust00)  then
  call keep_dust_zero &
    & ( myid &
    &  ,lapm &
    &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
 endif
 call apm_shun_check &
  & ( myid &
  &  ,lapm &
  &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,'apm_h_dif' )
endif
call end_timing('apm_h_dif', ne, myid )
ENDIF
!< end of apm horizontal  diffusion
!==========================================

!if(myid.eq.0) write(*,'(a,i2.2)') 'call naqpms_h_dif in domain ',ne
call start_timing
call naqpms_h_dif &
 & ( myid &
 &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d &
 &  ,ktop &
 &  ,mem3d &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,ifsm,idmSet,ismMax,igMark)
call end_timing('naqpms_h_dif', ne, myid )
! end of horizontal diffusion

!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
  do k=1,nzz
      do ig=1,iPrintTermGas    ! for gas phase
          igg=IGGPOS(ig)
          i04=ip4mem(k,igg,ne)
          i05=ipGasTermBal(k,4,ig,ne) ! 4--> hor diff
         call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05), &
              k,sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dt)
      enddo
 enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++  

call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'before_vdif' )

!---------------------vertical diffusion---------

IF(idifvert.eq.1.or.idifvert.eq.2) THEN
time(ne) = (it1-1)*12*dt + idt_syn(ne)*dtstep_syn(ne)     ! chenxsh@20170210
  iitime = time(ne)
  iwb=sx(ne)-1;ieb=ex(ne)+1
  jsb=sy(ne)-1;jeb=ey(ne)+1
  allocate( ppp(iwb:ieb,jsb:jeb,nzz) &
           ,ttn(iwb:ieb,jsb:jeb,nzz) &
           ,ffn(iwb:ieb,jsb:jeb,nzz) &
           ,conc(iwb:ieb,jsb:jeb,nzz) &
           ,concmark(iwb:ieb,jsb:jeb,nzz) &
           ,rkv(iwb:ieb,jsb:jeb,nzz) &
           ,dzz(iwb:ieb,jsb:jeb,nzz) &
           ,atm(iwb:ieb,jsb:jeb,nzz) )
  allocate( kktop(iwb:ieb,jsb:jeb))

  do j=sy(ne)-1,ey(ne)+1
  do i=sx(ne)-1,ex(ne)+1
    ixy = (ex(ne)-sx(ne)+3)*(j -sy(ne)+1)+i-sx(ne)+1
    do k=1,nzz
      i03=ip3mem(k,ne)
      i0_1=ip2mem2dconv(ne)
      i0=ip2mem(ne)
      IF(i>(sx(ne)-1).and.i<(ex(ne)+1).and.j>(sy(ne)-1).and.j<(ey(ne)+1))   THEN
         ppp(i,j,k)=Plev(i03+ixy)
         ttn(i,j,k)=t(i03+ixy)
         dzz(i,j,k)=dz(i03+ixy)
         rkv(i,j,k)=kv(i03+ixy)
         ffn(i,j,k)=rh1(i03+ixy)
         atm(i,j,k)=PA2ATM*Plev(i03+ixy)*100.
      ENDIF
    enddo !k
    kktop(i,j) = ktop(i0+ixy)
  enddo !i
  enddo !j        

!if(myid.eq.0) write(*,'(a,i2.2)') 'call naqpms_v_dif in domain ',ne
call start_timing
call naqpms_v_dif &
 & ( myid &
 &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igasCBM &
 &  ,iwb,ieb,jsb,jeb &
 &  ,dzz &
 &  ,rkv,ttn,ppp,atm,kktop &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,ifsm,idmSet,ismMax,igMark )
call end_timing('naqpms_v_dif', ne, myid )

!=========================================
!> shun : apm vertical diffusion
IF(lapm) THEN
call start_timing
if(lapm_vdif) then
! if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_v_dif in domain ',ne
 call apm_v_dif &
   & ( myid &
   &  ,lapm &
   &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
   &  ,iwb,ieb,jsb,jeb &
   &  ,dzz &
   &  ,ip3mem &
   &  ,rkv,ttn,ppp,atm,kktop )

 if(lapm_dust00)  then
  call keep_dust_zero &
    & ( myid &
    &  ,lapm &
    &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
 endif
 call apm_shun_check &
  & ( myid &
  &  ,lapm &
  &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,'apm_v_dif' )
endif
call end_timing('apm_v_dif', ne, myid )
ENDIF
!< end of apm vertical diffusion
!=========================================
! -----
  deallocate(ppp,ttn,ffn,rkv,dzz,atm,conc,concmark,kktop)
  
ENDIF !idifvert  
!---------------------------------

! end of vertical diffusion

call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'after_vdif' )

!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
 do k=1,nzz
   do ig=1,iPrintTermGas    ! for gas phase
     igg=IGGPOS(ig)
     i04=ip4mem(k,igg,ne)
     i05=ipGasTermBal(k,5,ig,ne) ! 5--> ver diff
     call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05), &
                   k,sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dt)
   enddo
 enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++

!> for dust and seasalt gravity settlement <!

  ! DT( = 300 sec ) is split into 5 timesteps , 
  ! i.e. , timestep in gravity settlement is 1 min ( 60 sec )

  numTGRV=dtstep_syn(ne)/60.0

 !===========================================
 !> shun : apm gravity settling
  IF(lapm) THEN
  call start_timing
  if(lapm_gdep) then
!    if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_gra_dep in domain ',ne

! shun: 20140524@albany.edu
    if(.true.) then
    call apm_gra_dep_v3 &
          & ( lapm &
          &  ,myid &
          &  ,dtstep_syn(ne),numTGRV &
          &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
          &  ,dz &
          &  ,ip2mem &
          &  ,ip3mem,mem3d )
    endif

    if(lapm_dust00)  then
     call keep_dust_zero &
      & ( myid &
      &  ,lapm &
      &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
    endif
    call apm_shun_check &
     & ( myid &
     &  ,lapm &
     &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
     &  ,ip3mem,mem3d &
     &  ,'apm_gra_dep' )
  endif
  call end_timing('apm_gra_dep', ne, myid )
  ENDIF
 !< end of apm gravity settling
 !===========================================

call naqpms_gra_dep &
 &  (myid &
 &  ,dtstep_syn(ne),numTGRV &
 &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d &
 &  ,mem3d &
 &  ,igas,iaer,isize,nseacom,ndustcom  &
 &  ,gravel ) 

!> end of aerosol gravity settling

!dddddddddddddddddddddddddddddddddddd
!ddd    Dry    Deposition         ddd
!dddddddddddddddddddddddddddddddddddd

time(ne) = (it1-1)*12*dt + idt_syn(ne)*dtstep_syn(ne)     ! chenxsh@20170210
iitime = time(ne)

call getnewdate(iyear1,imonth1,idate1,ihour1,iitime, &
                iyear2,imonth2,iday2,ihour2,iminute2 )

call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'before_ddep' )

call naqpms_dry_dep &
 & ( myid &
 &  ,dtstep_syn(ne) &
 &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igasCBM,igas,iaer,isize,nseacom,ndustcom &
 &  ,MSIZDIS,MSIZDID &
 &  ,iyear2,imonth2,iday2,ihour2,iminute2 )

call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'after_ddep' )

  !====================================================
  !> shun : apm dry deposition
 IF(lapm) THEN
 call start_timing
 if(lapm_ddep) then 
!   if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_ddep in domain ',ne

  ! shun: 20140524@albany.edu
   if(.true.) then
   call apm_dry_dep_v3 &
    & ( myid &
    &  ,lapm &
    &  ,dtstep_syn(ne) &
    &  ,ddep_flag &
    &  ,lrd_lai &
    &  ,imonth2 &
    &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
    &  ,dz &
    &  ,Plev,t,u,v,QVAPOR,clw,rnw,heiz,cldfrc3d,HGT1 &
    &  ,LAND_USE,tskwrf,wrflai,LATITCRS,LONGICRS,SWDOWN,PBL_HGT &
    &  ,ip2mem,mem2d &
    &  ,ip3mem,mem3d &
    &  ,itzon,iyear2,imonth2,iday2,ihour2,iminute2)
   endif

  if(lapm_dust00)  then
   call keep_dust_zero &
     & ( myid &
     &  ,lapm &
     &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
  endif
  call apm_shun_check &
   & ( myid &
   &  ,lapm &
   &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
   &  ,ip3mem,mem3d &
   &  ,'apm_dry_dep' )

endif
call end_timing('apm_dry_dep', ne, myid )
ENDIF
  !< end of apm dry deposition
  !====================================================

!> end of dry deposition 

!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
     do k=1,nzz
         do ig=1,iPrintTermGas    ! for gas phase
             igg=IGGPOS(ig)
             i04=ip4mem(k,igg,ne)
             i05=ipGasTermBal(k,7,ig,ne) ! 7--> dry dep
     call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05), &
              k,sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dt)
         enddo
     enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
735  continue

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccc     Gas  Chemistry with CBM-Z
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!================================================
!> shun : apm cacid before CBMZ
! gas : 
! cacid : #/cm3
! cair_mlc = avogad*pr_atm/(82.056*te)
time(ne) = (it1-1)*12*dt + idt_syn(ne)*dtstep_syn(ne)     ! chenxsh@20170210
runned_mn=time(ne)/60
if(runned_mn.ge.spinup_time) then
! if(myid.eq.0) write(*,'(a,i10.10)') 'runned time in minutes ',runned_mn
! if(myid.eq.0) write(*,'(a,i2.2)') 'start test box in domain ',ne
 ltest_box=.true.
endif
!< end of apm cacid before CBMZ
!===================================================


time(ne) = (it1-1)*12*dt + idt_syn(ne)*dtstep_syn(ne)     ! chenxsh@20170210
iitime = time(ne)
call getnewdate(iyear1,imonth1,idate1,ihour1,iitime, &
                iyear2,imonth2,iday2,ihour2,iminute2 )

if(ndt_syn(ne).le.2) then
   dt_cbmz=3600.0 ! one hour
elseif(ndt_syn(ne).eq.3) then
   dt_cbmz=dtstep_syn(ne) ! 20min
elseif(ndt_syn(ne).eq.4) then
   dt_cbmz=dtstep_syn(ne)*2.0 ! 30 min
elseif(ndt_syn(ne).eq.6) then
   dt_cbmz=dtstep_syn(ne)*2.0 ! 20min
elseif(ndt_syn(ne).eq.12) then
   dt_cbmz=dtstep_syn(ne)*4.0 ! 20min
else
   stop 'please reset dtstep_syn(ne)'
endif


if(ichemgas == 1)then ! 
if(mod(iitime,int(dt_cbmz)) == 0 )then ! every 20 minutes

call start_timing
!--------------------------------------------------------------------
!> shun : get sulferic acid vapor ( H2SO4 ) concentration before CBMZ

if(lapm.and..true.) then
 call apm_h2so4_cbmz &
    & ( myid &
    &  ,lapm &
    &  ,dtstep_syn(ne),dt_cbmz &
    &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
    &  ,ip3mem,mem3d &
    &  ,ip4mem,mem4d &
    &  ,PA2ATM,Plev,t &
    &  ,igas,gas,GC_MOLWT &
    &  ,'11' )
endif
!< end of get sulferic acid vapor ( H2SO4 ) concentration before CBMZ
!--------------------------------------------------------------------

!if(myid.eq.0) print*,'cbmz-time:',iyear2,imonth2,iday2,ihour2,iminute2

call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'before_cbmz' )

call naqpms_drv_gaschem &
 & ( myid &
 &  ,dt_cbmz &
 &  ,lprocess,iPrintTermGas &
 &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,iyear2,imonth2,iday2,ihour2,iminute2 &
 &  ,mem2d &
 &  ,mem3d &
 &  ,mem4d &
 &  ,GC_MOLWT,GC_NAME &
 &  ,igas,igasCBM,iaer,isize,nseacom,ndustcom &
 &  ,NLAY_EM &
 &  ,ifsm,ifsmt,idmSet,ismMax,igMark )

!--------------------------------------------------
!> shun : get  ( 1) sulferic acid vapor ( H2SO4 ) concentration 
!              ( 2) H2SO4 chemical production rate 
if(lapm.and..true.) then
 if(myid.eq.0) write(*,'(a,i2.2,a)') ' call apm_h2so4_cbmz in domain ',ne &
                                  ,' : preserve apm-H2SO4 before CBMZ'
 call apm_h2so4_cbmz &
    & ( myid &
    &  ,lapm &
    &  ,dtstep_syn(ne),dt_cbmz &
    &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
    &  ,ip3mem,mem3d &
    &  ,ip4mem,mem4d &
    &  ,PA2ATM,Plev,t &
    &  ,igas,gas,GC_MOLWT &
    &  ,'ch' )
endif
!< end of get sulferic acid vapor ( H2SO4 ) concentration after CBMZ
!--------------------------------------------------------------------

call end_timing('cbmz gaschem', ne, myid )

endif !  every 20 minutes
endif !  chem calculation flag yes/not

!> end of gas phase chemistry

!====================================================================
!> shun : update suferic acid vapor ( H2SO4(g) )  concentration
!  note : H2SO4 is updated in apm_phusics, so following code should
!         be commented out !
!< end of update suferic acid vapor ( H2SO4(g) )  concentration
!====================================================================


!===========================================
! transform hydrophobic BC to hydrophilic BC

if(lapm) then
call start_timing
if(lapm_trhl) then
! if(myid.eq.0) write(*,'(a,i2.2,a)') 'call apm_org_trsf in domain ',ne
 call apm_org_trsf &
   & ( myid &
   &  ,lapm &
   &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex )
endif
call end_timing('apm_org_trsf', ne, myid )
endif

call naqpms_bcoc_agt(myid,lapm,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex)
!===========================================

!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
    do k=1,nzz
        do ig=1,iPrintTermGas    ! for gas phase
            igg=IGGPOS(ig)
            i04=ip4mem(k,igg,ne)
            i05=ipGasTermBal(k,6,ig,ne)  ! 6 for chemistry
    call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05), &
            k,sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dt)
        enddo
    enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++

200 continue

!cccccc   Fe evolution in atmosphere by lijie  ccccc
   do k = 1, nzz-1
     i03=ip3mem(k,ne)
     i04_so2=ip4mem(k,18,ne) ! so2
     i04_hno3=ip4mem(k,2,ne) ! hno3
     i02=ip2mem(ne)
     do is = 1, isize
       i05   = ip5memc (k,is,9, ne) ! FeII
       i05_1 = ip5memc (k,is,10,ne) ! Total FeIII
       i05_2 = ip5memc (k,is,11,ne) ! coated FeIII
         
      call  FEEVOLUTION( MYID,DUSTCOMP(I05_2),DUSTCOMP(I05_1), DUSTCOMP(I05) &
                        ,gas(i04_so2),gas(i04_hno3) &
                        ,RK_HETSO2_DUST(i03),RK_HETHNO3_DUST(i03) &
                        ,clflo(i02),clfmi(i02),clfhi(i02) &
                        ,SWDOWN(i02),RH1(i03) &
                        ,DT,sx(ne),ex(ne),sy(ne),ey(ne),k,is)
     enddo
  enddo
!ccccccccccccccccccccccccccccccccccccccccccccccccccccc

!======================== 2013-03-01 ======================!
!                cloud water aqueous chemistry 

!print*,'shun for aqchem'
call cal_inorganic_aer &
  & ( myid &
  &  ,dt_naqpms &
  &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,ip4mem,mem4d &
  &  ,igas,gas,GC_MOLWT &
  &  ,ANA,ASO4,ANH4,ANO3,ACL )

if(laqchem) then
if(mod(iitime,int(dt_cbmz)) == 0 )then ! every 20 minutes
if(numprocs .gt. 1) call MPI_BARRIER( LOCAL_COM, ierr )
call start_timing
call aqchem_driver &
  & ( myid &
  &  ,lapm &
  &  ,lnaqpms_pso4 &
  &  ,dt_cbmz &
  &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,ip4mem,mem4d &
  &  ,ip5mem,mem5d &
  &  ,igas,gas,GC_MOLWT &
  &  ,iaer,isize,aer &
  &  ,plev,t,qvapor,clw &
  &  ,ANA,ASO4,ANH4,ANO3,ACL )
call end_timing('aqueous chemistry', ne, myid )
endif
endif
!==========================================================!

!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
   do k=1,nzz
     do ig=1,iPrintTermGas    ! for AQUEOUS  process
       igg=IGGPOS(ig)
       i04=ip4mem(k,igg,ne)
       i05=ipGasTermBal(k,24,ig,ne)  ! 24 for AQUEOUS CHEMISTRY
    call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05), &
            k,sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dt)
     enddo
   enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++

!========================================================================
!*****     ISORROPIA inorganic AEROSOL THERMODUNAMICS MODEL        ******
!========================================================================

if(lgaschemsmp) then

 call cal_inorganic_aer &
  & ( myid &
  &  ,dt_naqpms &
  &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,ip4mem,mem4d &
  &  ,igas,gas,GC_MOLWT &
  &  ,ANA,ASO4,ANH4,ANO3,ACL )
 call cal_inorganic_hgfac &
  & ( myid &
  &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,igas,GC_MOLWT )
else

if(mod(iitime,int(dt_cbmz)) == 0 )then ! every 20 minutes
!if(myid.eq.0) write(*,'(a,i2.2)') 'call ISORROPIA in domain ',ne
call start_timing
call naqpms_drv_isorropia &
 & ( myid &
 &  ,lapm &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d &
 &  ,mem3d &
 &  ,dt_cbmz &
 &  ,GC_MOLWT &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,ifsm,idmSet,ismMax,igMark ) 

call cal_inorganic_aer &
  & ( myid &
  &  ,dt_naqpms &
  &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,ip4mem,mem4d &
  &  ,igas,gas,GC_MOLWT &
  &  ,ANA,ASO4,ANH4,ANO3,ACL )

call cal_inorganic_hgfac &
  & ( myid &
  &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,igas,GC_MOLWT )

call end_timing('ISORROPIA gas-aerosol partition', ne, myid )
endif ! dt_cbmz

endif

!> end of inorganic gas-particle partition

!==========================================================
if(lapm) then
  call start_timing
  call cal_inorganic_yspgf &
    & ( myid &
    &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
    &  ,ip3mem,mem3d &
    &  ,ip4mem,mem4d &
    &  ,igas,gas,GC_MOLWT )
  call end_timing('apm_yspgf', ne, myid )
endif
!============================================================

if(lapm) then
 call apm_shun_check &
  & ( myid &
  &  ,lapm &
  &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,'00000-apm_boxphy_driver' )
endif

!==========================================================
!> shun : apm physics
!IF(lapm.and.lapm_phys.and.ltest_box) THEN
IF(lapm) THEN
if(mod(iitime,int(dt_cbmz)) == 0 )then ! every 20 minutes
call start_timing
if(lapm_phys) then
! if(myid.eq.0) write(*,'(a,i2.2)') 'call apm box physics in domain ',ne
call apm_clean_sp &
 & ( myid &
 &  ,lapm &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,ip3mem,mem3d &
 &  ,'before_box_cleansp' )

if(numprocs .gt. 1) call MPI_BARRIER( LOCAL_COM, ierr )

if(1==2) then
  call wr_apm_test( myid,lapm &
                  ,iyear2,imonth2,iday2,ihour2,iminute2 &
                  ,nest,nzz,sx,ex,sy,ey,ne &
                  ,ip2mem,ip3mem,mem2d,mem3d &
                  ,u,v,rh1,clw,rnw,RAINCON,RAINNON,'bfbox' )
endif


  call apm_boxphy_driver &
    & ( myid &
    &  ,lapm &
    &  ,dt_cbmz &
    &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
    &  ,ip2mem,mem2d &
    &  ,ip3mem,mem3d &
    &  ,ip4mem,mem4d &
    &  ,igas,gas,GC_MOLWT &
    &  ,longicrs,latitcrs,land_use &
    &  ,PSFC,Plev,t,rh1)
   !print*,'apm_ph runned times',ikk

if(1==2) then
  call wr_apm_test( myid,lapm &
                  ,iyear2,imonth2,iday2,ihour2,iminute2 &
                  ,nest,nzz,sx,ex,sy,ey,ne &
                  ,ip2mem,ip3mem,mem2d,mem3d &
                  ,u,v,rh1,clw,rnw,RAINCON,RAINNON,'afbox' )
endif

if(numprocs .gt. 1) call MPI_BARRIER( LOCAL_COM, ierr )

  if(idt_syn(ne).eq.ndt_syn(ne)) then
  call apm_cal_opt &
    & ( myid &
    &  ,lapm &
    &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
    &  ,ip2mem,mem2d &
    &  ,ip3mem,mem3d &
    &  ,dz,rh1,clw )
 endif
 if(lapm_dust00)  then
  call keep_dust_zero &
    & ( myid &
    &  ,lapm &
    &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
 endif
 call apm_shun_check &
  & ( myid &
  &  ,lapm &
  &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,'apm_boxphy_driver' )
endif

call end_timing('apm aerosol microphysics', ne, myid )
endif ! 20 min
ENDIF

!< end of apm physics
!=========================================
    
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
   do k=1,nzz
     do ig=1,iPrintTermGas    ! for ISORROPIA 
       igg=IGGPOS(ig)
       i04=ip4mem(k,igg,ne)
       i05=ipGasTermBal(k,22,ig,ne)  ! 22 for inorganic aerosol partioning
    call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05), &
            k,sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dt)
     enddo
   enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++

call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'before_wdep' )

! CCCCCCCCCCCCCCCCCCCCCCCCCCC   TO WET DEPOSITION  CCCCCCCCCCCCCCCCCC

call start_timing
call naqpms_wet_dep &
 & ( myid &
 &  ,itt &
 &  ,dtstep_syn(ne) &
 &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,CLW,RNW,t,Plev &
 &  ,RAINCON,RAINNON &
 &  ,mem2d &
 &  ,mem3d &
 &  ,igasCBM,igas,iaer,isize,nseacom,ndustcom &
 &  ,mem2dgas ) 
call end_timing('naqpms_wet_dep', ne, myid )

call check_naqpms_tracer &
 & ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'after_wdep' )

!==============================
!> shun : apm wet deposition
IF(lapm) then
call start_timing
if(lapm_wdep) then
! if(myid.eq.0) write(*,'(a,i2.2)') 'call apm_wet_dep in domain ',ne
 if(.true.) then
 call apm_wet_dep_v3 &
  & ( myid &
  &  ,lapm &
  &  ,itt &
  &  ,dtstep_syn(ne) &
  &  ,ne,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,dx,dy,dz &
  &  ,CLW,RNW,t,Plev,CPH &
  &  ,RAINCON,RAINNON &
  &  ,ip2mem,mem2d &
  &  ,ip3mem,mem3d )
 endif

 if(lapm_dust00)  then
  call keep_dust_zero &
   & ( myid &
   &  ,lapm &
   &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex )
 endif

 call apm_shun_check &
  & ( myid &
  &  ,lapm &
  &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
  &  ,ip3mem,mem3d &
  &  ,'apm_wet_dep' )
endif
call end_timing('apm_wet_dep', ne, myid )
ENDIF
!< end of apm wet deposition
!==============================

!> end of wet deposition of gas and aerosol

!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
   do k=1,nzz
     do ig=1,iPrintTermGas    ! for WETDEP process
       igg=IGGPOS(ig)
       i04=ip4mem(k,igg,ne)
       i05=ipGasTermBal(k,8,ig,ne)  ! 8 for WETDEP
    call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05), &
            k,sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dt)
     enddo
   enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++

!!************** SOAP SECSONDARY ORGANIC EROSOL  MODEL ***************
!***  TO PARTITION THE SEMIVOLATILE ORGANIC AEROSOL COMPONENTS *****
!***    6 PRECIES INCLUDING ANTHROPOGENIC TOL AND XYL          *****
!***            AND BIOGENIC ISOP AND TERP                     *****

if(lgaschemsmp) then

else

call start_timing
call naqpms_drv_soap ( myid &
 &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d,mem3d,igas,iaer,isize,nseacom,ndustcom &
 &  ,NSOA,ifsm,idmSet,ismMax,igMark )
call end_timing('secondary organic aerosol', ne, myid )
!> end of SOA gas-particle partition
endif

call check_naqpms_tracer ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'after_soap' )

!=====================================================

!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++
if(lprocess) then
   do k=1,nzz
     do ig=1,iPrintTermGas    ! for SOA process
       igg=IGGPOS(ig)
       i04=ip4mem(k,igg,ne)
       i05=ipGasTermBal(k,23,ig,ne)  ! 23 for organic aerosol partioning
    call termbal(myid,gasOLD(i04),gas(i04),GasTermBal(i05), &
            k,sx(ne), ex(ne), sy(ne), ey(ne),nx(ne),ny(ne),dt)
     enddo
   enddo
endif
!++++++++++++++++++++++++for process by lijie+++++++++++++++++++++++


!!*********    Exitinction and AOD  MODEL     **************
!!***       TO USE THE RRECONSTRUCTED METHOD       *********

if(lgaschemsmp) then

else

call start_timing
call naqpms_cal_diag ( myid &
 &  ,ne,dtstep_syn(ne),nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d,mem3d,igas,iaer,isize,nseacom,ndustcom &
 &  ,GC_MOLWT,ktop,kk )
call end_timing('naqpms diagnostics calculation', ne, myid )

call check_naqpms_tracer ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'after_cal-diag' )

endif

!=====================================================================
!====    to change boundary conditions                           =====
!=====================================================================

if(numprocs .gt. 1 .and. mod(it1,iprecise)==0 )then

 call MPI_BARRIER( LOCAL_COM, ierr )

 do k=1,nzz
   i03=ip3mem(k,ne)
   call exchng2( myid, u(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   call exchng2( myid, v(i03), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   do ia=1,iaer
   do is=1,isize
     i05=ip5mem(k,is,ia,ne)
     call exchng2( myid, aer(i05), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   enddo
   enddo

   do ig=1,iedgas
    i04=ip4mem(k,ig,ne)
    call exchng2( myid, gas(i04), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
   enddo

  !!!!!!!!!!!!!!!!!!!!!
  ! For Source Mark
   if(ifsm(ne)==1)then 
    do idm=1,idmSet
    do ism=1,ismMax 
     i04=ipSMmem(k,ism,idm,ne)
     call exchng2( myid, SourceMark(i04), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne) )
    enddo 
    enddo 
   endif 
  !!!!!!!!!!!!!!!!!!!!!

! for sea salt and dust
   do iduc = 1, nseacom
   do is = 1, isize
     i05c = ip5memcs (k, is, iduc, ne) 
     call exchng2 ( myid, seacomp(i05c), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne))
   enddo
   enddo

   do iduc = 1, ndustcom
   do is = 1, isize
     i05c = ip5memc (k, is, iduc, ne)
     call exchng2 ( myid, dustcomp(i05c), sx(ne), ex(ne), sy(ne), ey(ne),  &
                comm2d(ne), stride(ne),  nbrleft(ne), nbrright(ne), &
                nbrtop(ne), nbrbottom(ne))
   enddo
   enddo

   if(laerv2) then
     include 'aerv2_ch_bdy.inc'
   endif

   !======================================
   !> shun : change apm boundary condition
   if(lapm) then
     include 'apm_ch_bdy.inc'
   endif
   !< end of change apm boundary condition
   !======================================
  
 enddo ! k

!================================================
if(lglbrun) then
  if(ne.eq.1) then
    DO IPS=1,IPOLARNUM

!send
      IF(IPOLARMRK(2,IPS)==MYID) THEN  !!! need to send

        DO K=1,NZZ
          ITSP=0
          include 'naq_polar_trspt_send.inc'
          if(lapm) then
          include 'apm_polar_trspt_send.inc'
          endif
        ENDDO
        
        DO K=1,NZZ
          IPSMARK = IPS + 720 + (k-1)*IPOLARNUM
          do ibeibei=1,ISRNUM
            atestS0(ibeibei)=atestS(k,ibeibei)
          enddo
          call MPI_Send(atestS0,ISRNUM,MPI_REAL,IPOLARMRK(1,IPS),IPSMARK,comm2d(ne),ierr)
        ENDDO

      ENDIF
!send

!receive
      IF(IPOLARMRK(1,IPS)==MYID) THEN  !!! need to receive     

         DO K=1,NZZ
           IPSMARK = IPS + 720 + (k-1)*IPOLARNUM
           call MPI_Recv(atestR0,ISRNUM,MPI_REAL,IPOLARMRK(2,IPS),IPSMARK,  &
                comm2d(ne),status,ierr)
           do ibeibei=1,ISRNUM
             atestR(k,ibeibei)=atestR0(ibeibei)
           enddo
         ENDDO

         DO K=1,NZZ
           IF(IPOLARMRK(5,IPS)==1.OR.IPOLARMRK(5,IPS)==NY(NE)) THEN
             IF(IPOLARMRK(5,IPS)==1) THEN
               IPP=IPOLARMRK(5,IPS)-1
             ELSE
               IPP=IPOLARMRK(5,IPS)+1
             ENDIF

             ips1=0

             include 'naq_polar_trspt_receive.inc'

             if(lapm) then
             include 'apm_polar_trspt_receive.inc'
             endif

           ENDIF
         ENDDO

      ENDIF
!receive

    ENDDO !IPS=1,IPOLARNUM
  endif   ! ne.eq.1
endif     ! lglbrun
!================================================

endif  ! numprocs
!=====================================================================

call check_naqpms_tracer ( myid &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,'after_chbdy' )

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

endif ! synchronous time step
endif   !!! ! if cal_ne

enddo loop_nest_calulation  !nest end calculation
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

enddo loop_time_onehour  ! end 1 hour itt<=12

!> end of inner time integration loop

! output

!wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
! to write data
!wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww

34567 continue ! shun

if(numprocs .gt. 1) call MPI_BARRIER( LOCAL_COM, ierr )

!> shun : output apm vars
IF(lapm) THEN
call start_timing
do ne=1,nest
 if(myid.eq.0) print*,'output apm vars'
 if(lapm_wrfl) THEN
!if(myid.eq.0) print*,iyear2,imonth2,iday2,ihour2,iminute2

  call wr_apm_var( myid,lapm &
                  ,iyear2,imonth2,iday2,ihour2,iminute2 &
                  ,nest,nzz,sx,ex,sy,ey,ne &
                  ,ip2mem,ip3mem,mem2d,mem3d &
                  ,u,v,rh1,clw,rnw,RAINCON,RAINNON )
 endif
enddo
call end_timing('wr_apm_var', ne, myid )
ENDIF
!< end of output apm vars

do ne=1,nest

if(it1.ge.ntbeg(ne) .and. it1.le.ntend(ne) )then

if(mod(it1+nhfq_output(ne),nhfq_output(ne)).eq.0) then

iitime = it1*12*dt
call getnewdate(iyear1,imonth1,idate1,ihour1,iitime, &
                iyear2,imonth2,iday2,ihour2,iminute2 )

call start_timing

call naqpms_tracer_output( myid &
 &  ,iyear2,imonth2,iday2,ihour2,iminute2 &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d,tropp &
 &  ,mem3d &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,PrintGas )

call naqpms_tracer_output_v2( myid &
 &  ,iyear2,imonth2,iday2,ihour2,iminute2 &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d,tropp &
 &  ,mem3d &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,PrintGas )

!==================
! dry dep
if(1==2) then
call naqpms_dry_output( myid &
 &  ,iyear2,imonth2,iday2,ihour2,iminute2 &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom )
endif
!==================


!==================
!> WET DEP
if(1==2) then
call naqpms_wet_output( myid &
 &  ,iyear2,imonth2,iday2,ihour2,iminute2 &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom )
endif  
!< END
!==================

!=============================================
!TO WRITE DUST CONCENTRATIONS AND EMISSIONS
if(1==2) then
call naqpms_dust_output( myid &
 &  ,iyear2,imonth2,iday2,ihour2,iminute2 &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom )
endif
!=============================================

!==============================================
! TO WRITE SEASALT CONCENTRATIONS AND EMISSIONS 
if(1==2) then
call naqpms_salt_output ( myid &
 &  ,iyear2,imonth2,iday2,ihour2,iminute2 &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom )
endif
!===============================================

!===============================================
! to write term
if(lprocess.and..false.) then
call naqpms_term_output( myid,iyear2,imonth2,iday2,ihour2,iminute2 &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,iprocess,PrintTermGas )
endif
!--- for process by lijie 
!================================================

             
 !!!!!!!!!!!!!!!!!!!!!!!!!!
 ! for Source Mark
if(1==2) then
call naqpms_out_smark ( myid,iyear2,imonth2,iday2,ihour2,iminute2 &
 &  ,ne,dt,nx,ny,nzz,nest,sy,ey,sx,ex &
 &  ,mem2d,tropp,mem3d &
 &  ,igas,iaer,isize,nseacom,ndustcom &
 &  ,PrintGas,ifsm,idmSet,ismMax,igMark )
endif 

call end_timing('naqpms output', ne, myid )

endif ! nhfq_output
endif ! ntbeg,ntend

enddo   ! write for different domain

!wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww

1188 continue

        it1=it1+1 ! advance time
  end do   ! end of the while integration it1

45678 continue

 end subroutine geatm_run_mct

 subroutine geatm_final_mct()
   use geatm_vartype
   if(allocated(procs)) deallocate (procs)
   if(allocated(cam_local_points))    deallocate(cam_local_points)

   if(myid == 0 )then
   call system("rm -f out/nest.*")
   call system("rm -f out/grid.dat*")
   call system("rm -f out/locate.*")
   endif

   call final_camgrid(camgrid)
   call final_wrfgrid(wrfgrid)
   call final_geatm_var

include 'module_main/deallocate_inc.f90'
   
   do ne=1,nest
    call MPI_TYPE_FREE( stride(ne), ierr )
    call MPI_COMM_FREE( comm2d(ne), ierr )
   enddo

end subroutine geatm_final_mct

!===============================================================================
	
  subroutine geatm_SetgsMap_cam( camgrid, local_com, GEAID, GSMap_gege )
!-------------------------------------------------------------------
!
! Arguments
!
      use geatm_vartype, only:csx,cex,csy,cey
      TYPE(camgrid_c) :: camgrid
      integer        , intent(in)  :: local_com
      integer        , intent(in)  :: GEAID
      type(mct_gsMap), intent(out) :: GSMap_gege
!
! Local variables
!
      integer, allocatable :: gindex(:)
      integer :: i, j, k, n,lsize,gsize
      integer :: ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,ips,ipe,jps,jpe,kps,kpe
      integer :: ier            ! error status
!-------------------------------------------------------------------
! Build the atmosphere grid numbering for MCT
! NOTE:  Numbering scheme is: West to East, bottom to level, and South to North
! starting at south pole.  Should be the same as what's used in SCRIP
! Determine global seg map
	
      ! prepare the decomposition	
      ips=csx(1)
      ipe=cex(1)
      jps=csy(1)
      jpe=cey(1)
      ids=1
      ide=camgrid%num_camgrid_lon
      jds=1
      jde=camgrid%num_camgrid_lat
      
      lsize=0
      do j=jps, jpe 
       do i=ips, ipe
             lsize = lsize+1  !local index
       end do
      end do
   
      gsize=(ide-ids+1)*(jde-jds+1)
      allocate(gindex(lsize))
      n=0
      do j=jps, jpe  
       do i=ips, ipe
          n=n+1
          gindex(n) =(j-1)*(ide-ids+1)+i  ! global index
       end do
      end do

      call mct_gsMap_init( gsMap_gege, gindex, local_com, GEAID, lsize, gsize)

      deallocate(gindex)

  end subroutine geatm_SetgsMap_cam
  
!===============================================================================

  subroutine geatm_domain_cam( camgrid, lsize, gsMap_cc, dom_c )

      use geatm_vartype, only:myid
!-------------------------------------------------------------------
! Arguments
!
      TYPE(camgrid_c) :: camgrid
      integer     , intent(in)   :: lsize
      TYpe(mct_gsMap), intent(in)   :: gsMap_cc
      type(mct_ggrid), intent(inout):: dom_c    
!
! Local Variables
!
      integer  :: i,j,k,mm,nn           ! indices	
      integer :: ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,ips,ipe,jps,jpe,kps,kpe
      real(r8), pointer  :: data(:)     ! temporary
      integer , pointer  :: idata(:)    ! temporary
                
! Initialize mct atm domain
         call mct_gGrid_init( GGrid=dom_c, CoordChars=trim(seq_flds_dom_coord), OtherChars=trim(seq_flds_dom_other), lsize=lsize )

! Allocate memory
         allocate(data(lsize))
 
! Initialize attribute vector with special value
         call mct_gsMap_orderedPoints(gsMap_cc, myid, idata)
         call mct_gGrid_importIAttr(dom_c,'GlobGridNum',idata,lsize)

! Determine domain (numbering scheme is: West to East and South to North to South pole)
! Initialize attribute vector with special value

        data(:) = -9999.0_R8 
        call mct_gGrid_importRAttr(dom_c,"lat"  ,data,lsize) 
        call mct_gGrid_importRAttr(dom_c,"lon"  ,data,lsize) 
        call mct_gGrid_importRAttr(dom_c,"area" ,data,lsize) 
        call mct_gGrid_importRAttr(dom_c,"aream",data,lsize) 
        data(:) = 0.0_R8     
        call mct_gGrid_importRAttr(dom_c,"mask" ,data,lsize) 
        data(:) = 1.0_R8
        call mct_gGrid_importRAttr(dom_c,"frac" ,data,lsize)
    
        if(associated(idata)) deallocate(idata)    
	deallocate(data)

	end subroutine geatm_domain_cam
	
!===============================================================================
  subroutine initial_camgrid( camgrid)
     TYPE(camgrid_c) :: camgrid
     
     ! Local variables	
     integer  :: i,j,k  ! indices    
     integer :: mids,mide,mjds,mjde,mkds,mkde,&
                 mims,mime,mjms,mjme,mkms,mkme,&
                 mips,mipe,mjps,mjpe,mkps,mkpe        
   
      mids=1
      mide=camgrid%num_camgrid_lon
      mjds=1
      mjde=camgrid%num_camgrid_lat
      mkps=1
      mkpe=camgrid%num_camgrid_levels
      if(.not.allocated(camgrid%z3d)) allocate(camgrid%z3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(camgrid%u3d)) allocate(camgrid%u3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(camgrid%v3d)) allocate(camgrid%v3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(camgrid%t3d)) allocate(camgrid%t3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(camgrid%p3d)) allocate(camgrid%p3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(camgrid%qv3d)) allocate(camgrid%qv3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(camgrid%qc3d)) allocate(camgrid%qc3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(camgrid%qi3d)) allocate(camgrid%qi3d(mids:mide,mkps:mkpe,mjds:mjde))      
      if(.not.allocated(camgrid%rh3d)) allocate(camgrid%rh3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(camgrid%taucldv3d)) allocate(camgrid%taucldv3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(camgrid%taucldi3d)) allocate(camgrid%taucldi3d(mids:mide,mkps:mkpe,mjds:mjde))      
      if(.not.allocated(camgrid%xlat)) allocate(camgrid%xlat(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%xlon)) allocate(camgrid%xlon(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%ps)) allocate(camgrid%ps(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%ht)) allocate(camgrid%ht(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%pblh)) allocate(camgrid%pblh(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%u10)) allocate(camgrid%u10(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%v10)) allocate(camgrid%v10(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%t2)) allocate(camgrid%t2(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%q2)) allocate(camgrid%q2(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%rh2)) allocate(camgrid%rh2(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%xland)) allocate(camgrid%xland(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%sst)) allocate(camgrid%sst(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%xice)) allocate(camgrid%xice(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%tsk)) allocate(camgrid%tsk(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%snowh)) allocate(camgrid%snowh(mids:mide,mjds:mjde))      
      if(.not.allocated(camgrid%ust)) allocate(camgrid%ust(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%rmol)) allocate(camgrid%rmol(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%raincv)) allocate(camgrid%raincv(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%rainncv)) allocate(camgrid%rainncv(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%swdown)) allocate(camgrid%swdown(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%clflo)) allocate(camgrid%clflo(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%clfmi)) allocate(camgrid%clfmi(mids:mide,mjds:mjde))
      if(.not.allocated(camgrid%clfhi)) allocate(camgrid%clfhi(mids:mide,mjds:mjde))
      
      if(.not.allocated(camgrid%soildepth)) allocate(camgrid%soildepth(mids:mide,1:camgrid%num_camgrid_soil_levels,mjds:mjde))
      if(.not.allocated(camgrid%soilthick)) allocate(camgrid%soilthick(mids:mide,1:camgrid%num_camgrid_soil_levels,mjds:mjde))
      if(.not.allocated(camgrid%soilt)) allocate(camgrid%soilt(mids:mide,1:camgrid%num_camgrid_soil_levels,mjds:mjde))
      if(.not.allocated(camgrid%soilm)) allocate(camgrid%soilm(mids:mide,1:camgrid%num_camgrid_soil_levels,mjds:mjde))

  end subroutine initial_camgrid
!-----------------------------------------------------------------------
  subroutine final_camgrid(camgrid)
    type(camgrid_c) :: camgrid
    if(allocated(camgrid%z3d))     deallocate(camgrid%z3d)
    if(allocated(camgrid%u3d))     deallocate(camgrid%u3d)
    if(allocated(camgrid%v3d))     deallocate(camgrid%v3d)
    if(allocated(camgrid%qv3d))   deallocate(camgrid%qv3d)
    if(allocated(camgrid%qc3d))   deallocate(camgrid%qc3d)
    if(allocated(camgrid%qi3d))   deallocate(camgrid%qi3d)       
    if(allocated(camgrid%t3d))   deallocate(camgrid%t3d)
    if(allocated(camgrid%rh3d))   deallocate(camgrid%rh3d)
    if(allocated(camgrid%p3d))   deallocate(camgrid%p3d)
    if(allocated(camgrid%taucldv3d))   deallocate(camgrid%taucldv3d)
    if(allocated(camgrid%taucldi3d))   deallocate(camgrid%taucldi3d)       
    if(allocated(camgrid%xlat))   deallocate(camgrid%xlat)
    if(allocated(camgrid%xlon))   deallocate(camgrid%xlon)
    if(allocated(camgrid%ps))   deallocate(camgrid%ps)
    if(allocated(camgrid%q2))   deallocate(camgrid%q2)
    if(allocated(camgrid%t2))   deallocate(camgrid%t2)
    if(allocated(camgrid%rh2))   deallocate(camgrid%rh2)
    if(allocated(camgrid%v10))   deallocate(camgrid%v10)
    if(allocated(camgrid%u10))   deallocate(camgrid%u10)
    if(allocated(camgrid%ht))   deallocate(camgrid%ht)
    if(allocated(camgrid%rmol))   deallocate(camgrid%rmol)
    if(allocated(camgrid%pblh))   deallocate(camgrid%pblh)
    if(allocated(camgrid%raincv))   deallocate(camgrid%raincv)
    if(allocated(camgrid%rainncv))   deallocate(camgrid%rainncv)
    if(allocated(camgrid%snowh))   deallocate(camgrid%snowh)       
    if(allocated(camgrid%sst))   deallocate(camgrid%sst)
    if(allocated(camgrid%xice))   deallocate(camgrid%xice)
    if(allocated(camgrid%tsk))   deallocate(camgrid%tsk)       
    if(allocated(camgrid%xland))   deallocate(camgrid%xland)
    if(allocated(camgrid%swdown))   deallocate(camgrid%swdown)
    if(allocated(camgrid%clflo))   deallocate(camgrid%clflo)
    if(allocated(camgrid%clfmi))   deallocate(camgrid%clfmi)
    if(allocated(camgrid%clfhi))   deallocate(camgrid%clfhi)

    if(allocated(camgrid%soildepth)) deallocate(camgrid%soildepth)
    if(allocated(camgrid%soilthick)) deallocate(camgrid%soilthick)
    if(allocated(camgrid%soilt)) deallocate(camgrid%soilt)
    if(allocated(camgrid%soilm)) deallocate(camgrid%soilm)

  end subroutine final_camgrid
!-----------------------------------------------------------------------
  subroutine initial_wrfgrid( wrfgrid)
     TYPE(wrfgrid_c) :: wrfgrid
     
     ! Local variables	
     integer  :: i,j,k  ! indices    
     integer :: mids,mide,mjds,mjde,mkds,mkde,&
                 mims,mime,mjms,mjme,mkms,mkme,&
                 mips,mipe,mjps,mjpe,mkps,mkpe        

      wrfgrid%num_wrfgrid_lon = 360
      wrfgrid%num_wrfgrid_lat = 180
      wrfgrid%num_wrfgrid_levels = 20
      wrfgrid%num_wrfgrid_soil_levels =4
     
      mids=1
      mide=wrfgrid%num_wrfgrid_lon
      mjds=1
      mjde=wrfgrid%num_wrfgrid_lat
      mkps=1
      mkpe=wrfgrid%num_wrfgrid_levels    
      if(.not.allocated(wrfgrid%sigma)) allocate(wrfgrid%sigma(mkps:mkpe))
      wrfgrid%sigma(1) =   0.00250_8
      wrfgrid%sigma(2) =   0.00800_8
      wrfgrid%sigma(3) =   0.01500_8
      wrfgrid%sigma(4) =   0.02350_8
      wrfgrid%sigma(5) =   0.03400_8
      wrfgrid%sigma(6) =   0.04650_8
      wrfgrid%sigma(7) =   0.06100_8
      wrfgrid%sigma(8) =   0.07850_8
      wrfgrid%sigma(9) =   0.09950_8
      wrfgrid%sigma(10) =   0.12500_8
      wrfgrid%sigma(11) =   0.15550_8
      wrfgrid%sigma(12) =   0.19200_8
      wrfgrid%sigma(13) =   0.23550_8
      wrfgrid%sigma(14) =   0.28800_8
      wrfgrid%sigma(15) =   0.35150_8
      wrfgrid%sigma(16) =   0.42700_8
      wrfgrid%sigma(17) =   0.51750_8
      wrfgrid%sigma(18) =   0.62650_8
      wrfgrid%sigma(19) =   0.75750_8
      wrfgrid%sigma(20) =   0.91450_8
 
      if(.not.allocated(wrfgrid%z3d)) allocate(wrfgrid%z3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(wrfgrid%u3d)) allocate(wrfgrid%u3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(wrfgrid%v3d)) allocate(wrfgrid%v3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(wrfgrid%t3d)) allocate(wrfgrid%t3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(wrfgrid%p3d)) allocate(wrfgrid%p3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(wrfgrid%qv3d)) allocate(wrfgrid%qv3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(wrfgrid%qc3d)) allocate(wrfgrid%qc3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(wrfgrid%qi3d)) allocate(wrfgrid%qi3d(mids:mide,mkps:mkpe,mjds:mjde))      
      if(.not.allocated(wrfgrid%rh3d)) allocate(wrfgrid%rh3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(wrfgrid%taucldv3d)) allocate(wrfgrid%taucldv3d(mids:mide,mkps:mkpe,mjds:mjde))
      if(.not.allocated(wrfgrid%taucldi3d)) allocate(wrfgrid%taucldi3d(mids:mide,mkps:mkpe,mjds:mjde))      
      ! for geatm variables output
      if(.not.allocated(wrfgrid%ps)) allocate(wrfgrid%ps(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%ht)) allocate(wrfgrid%ht(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%pblh)) allocate(wrfgrid%pblh(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%u10)) allocate(wrfgrid%u10(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%v10)) allocate(wrfgrid%v10(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%t2)) allocate(wrfgrid%t2(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%q2)) allocate(wrfgrid%q2(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%rh2)) allocate(wrfgrid%rh2(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%xland)) allocate(wrfgrid%xland(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%sst)) allocate(wrfgrid%sst(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%xice)) allocate(wrfgrid%xice(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%tsk)) allocate(wrfgrid%tsk(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%snowh)) allocate(wrfgrid%snowh(mids:mide,mjds:mjde))      
      if(.not.allocated(wrfgrid%ust)) allocate(wrfgrid%ust(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%rmol)) allocate(wrfgrid%rmol(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%raincv)) allocate(wrfgrid%raincv(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%rainncv)) allocate(wrfgrid%rainncv(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%swdown)) allocate(wrfgrid%swdown(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%clflo)) allocate(wrfgrid%clflo(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%clfmi)) allocate(wrfgrid%clfmi(mids:mide,mjds:mjde))
      if(.not.allocated(wrfgrid%clfhi)) allocate(wrfgrid%clfhi(mids:mide,mjds:mjde))  

      if(.not.allocated(wrfgrid%soildepth)) allocate(wrfgrid%soildepth(mids:mide,1:wrfgrid%num_wrfgrid_soil_levels,mjds:mjde))
      if(.not.allocated(wrfgrid%soilthick)) allocate(wrfgrid%soilthick(mids:mide,1:wrfgrid%num_wrfgrid_soil_levels,mjds:mjde))
      if(.not.allocated(wrfgrid%soilt)) allocate(wrfgrid%soilt(mids:mide,1:wrfgrid%num_wrfgrid_soil_levels,mjds:mjde))
      if(.not.allocated(wrfgrid%soilm)) allocate(wrfgrid%soilm(mids:mide,1:wrfgrid%num_wrfgrid_soil_levels,mjds:mjde))

      do j=mjds,mjde
      do i=mids,mide
      wrfgrid%soildepth(i,1,j)=0.05  
      wrfgrid%soildepth(i,2,j)=0.25
      wrfgrid%soildepth(i,3,j)=0.7
      wrfgrid%soildepth(i,4,j)=1.5 
      wrfgrid%soilthick(i,1,j)=0.1
      wrfgrid%soilthick(i,2,j)=0.3
      wrfgrid%soilthick(i,3,j)=0.6
      wrfgrid%soilthick(i,4,j)=1.0 
      end do
      end do

  end subroutine initial_wrfgrid
!-----------------------------------------------------------------------
	
  subroutine final_wrfgrid(wrfgrid)
    type(wrfgrid_c) :: wrfgrid

    if(allocated(wrfgrid%z3d))     deallocate(wrfgrid%z3d)
    if(allocated(wrfgrid%u3d))     deallocate(wrfgrid%u3d)
    if(allocated(wrfgrid%v3d))     deallocate(wrfgrid%v3d)
    if(allocated(wrfgrid%qv3d))   deallocate(wrfgrid%qv3d)
    if(allocated(wrfgrid%qc3d))   deallocate(wrfgrid%qc3d)
    if(allocated(wrfgrid%qi3d))   deallocate(wrfgrid%qi3d)       
    if(allocated(wrfgrid%t3d))   deallocate(wrfgrid%t3d)
    if(allocated(wrfgrid%rh3d))   deallocate(wrfgrid%rh3d)
    if(allocated(wrfgrid%p3d))   deallocate(wrfgrid%p3d)
    if(allocated(wrfgrid%taucldv3d))   deallocate(wrfgrid%taucldv3d)
    if(allocated(wrfgrid%taucldi3d))   deallocate(wrfgrid%taucldi3d)       
    if(allocated(wrfgrid%ps))   deallocate(wrfgrid%ps)
    if(allocated(wrfgrid%q2))   deallocate(wrfgrid%q2)
    if(allocated(wrfgrid%rh2))   deallocate(wrfgrid%rh2)
    if(allocated(wrfgrid%t2))   deallocate(wrfgrid%t2)
    if(allocated(wrfgrid%v10))   deallocate(wrfgrid%v10)
    if(allocated(wrfgrid%u10))   deallocate(wrfgrid%u10)
    if(allocated(wrfgrid%ht))   deallocate(wrfgrid%ht)
    if(allocated(wrfgrid%rmol))   deallocate(wrfgrid%rmol)
    if(allocated(wrfgrid%pblh))   deallocate(wrfgrid%pblh)
    if(allocated(wrfgrid%raincv))   deallocate(wrfgrid%raincv)
    if(allocated(wrfgrid%rainncv))   deallocate(wrfgrid%rainncv)
    if(allocated(wrfgrid%snowh))   deallocate(wrfgrid%snowh)       
    if(allocated(wrfgrid%sst))   deallocate(wrfgrid%sst)
    if(allocated(wrfgrid%xice))   deallocate(wrfgrid%xice)
    if(allocated(wrfgrid%tsk))   deallocate(wrfgrid%tsk)       
    if(allocated(wrfgrid%xland))   deallocate(wrfgrid%xland)
    if(allocated(wrfgrid%swdown))   deallocate(wrfgrid%swdown)
    if(allocated(wrfgrid%clflo))   deallocate(wrfgrid%clflo)
    if(allocated(wrfgrid%clfmi))   deallocate(wrfgrid%clfmi)
    if(allocated(wrfgrid%clfhi))   deallocate(wrfgrid%clfhi)

    if(allocated(wrfgrid%soildepth)) deallocate(wrfgrid%soildepth)
    if(allocated(wrfgrid%soilthick)) deallocate(wrfgrid%soilthick)
    if(allocated(wrfgrid%soilt)) deallocate(wrfgrid%soilt)
    if(allocated(wrfgrid%soilm)) deallocate(wrfgrid%soilm)

  end subroutine final_wrfgrid
!-----------------------------------------------------------------------
	
  subroutine geatm_import_mct( x2c_c, camgrid, loop )     
!-----------------------------------------------------------------------
! Arguments
!
     use geatm_vartype, only:csx,cex,csy,cey,myid	
     TYPE(camgrid_c) :: camgrid
     type(mct_aVect)   , intent(inout) :: x2c_c
     integer :: loop

     ! Local variables	
     integer  :: i,j,k,ig  ! indices    
     integer :: ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,ips,ipe,jps,jpe,kps,kpe   
     real*8,dimension(:,:),allocatable::xlat,xlon
     real*8,dimension(:),allocatable::templon,templat
     logical,save :: first_sst=.true.     
 
       ips=csx(1)
       ipe=cex(1)
       jps=csy(1)
       jpe=cey(1)
       
      ig=1
      do j=jps,jpe                                                        
       do i =ips, ipe
         
          camgrid%xlat(i,j)       = x2c_c%rAttr(index_x2ge_Sx_lat     ,ig)*180.0/3.1415926
          camgrid%xlon(i,j)       = x2c_c%rAttr(index_x2ge_Sx_lon     ,ig)*180.0/3.1415926 
	  if(camgrid%xlon(i,j).lt.0) camgrid%xlon(i,j) = camgrid%xlon(i,j)+360  
          camgrid%ps(i,j) = x2c_c%rAttr(index_x2ge_Sx_ps      ,ig)
          camgrid%ht(i,j) =  x2c_c%rAttr(index_x2ge_Sx_phis    ,ig)/9.81
          camgrid%t2(i,j) =  x2c_c%rAttr(index_x2ge_Sx_t2    ,ig) 
          camgrid%q2(i,j) =  x2c_c%rAttr(index_x2ge_Sx_q2    ,ig)
          camgrid%pblh(i,j) =  x2c_c%rAttr(index_x2ge_Sx_pblh    ,ig)
          camgrid%u10(i,j) =  x2c_c%rAttr(index_x2ge_Sx_u10    ,ig)
          camgrid%v10(i,j) =  x2c_c%rAttr(index_x2ge_Sx_v10    ,ig)
          camgrid%ust(i,j) =  x2c_c%rAttr(index_x2ge_Sx_ust    ,ig)
          camgrid%rmol(i,j) =  x2c_c%rAttr(index_x2ge_Sx_rmol    ,ig)
          camgrid%raincv(i,j) =  x2c_c%rAttr(index_x2ge_Sx_raincv    ,ig)
          camgrid%rainncv(i,j) =  x2c_c%rAttr(index_x2ge_Sx_rainncv    ,ig)
          camgrid%swdown(i,j) =  x2c_c%rAttr(index_x2ge_Sx_swdown    ,ig)
          camgrid%clflo(i,j) =  x2c_c%rAttr(index_x2ge_Sx_clflo    ,ig)
          camgrid%clfmi(i,j) =  x2c_c%rAttr(index_x2ge_Sx_clfmi    ,ig)
          camgrid%clfhi(i,j) =  x2c_c%rAttr(index_x2ge_Sx_clfhi    ,ig)
          camgrid%rh2(i,j) =  x2c_c%rAttr(index_x2ge_Sx_rh2    ,ig)
          camgrid%sst(i,j) = x2c_c%rAttr(index_x2ge_Sx_sst  ,ig)    
          camgrid%xice(i,j) = x2c_c%rAttr(index_x2ge_Sx_seaice  ,ig)
          camgrid%tsk(i,j) = x2c_c%rAttr(index_x2ge_Sx_ts  ,ig)      
          camgrid%xland(i,j)= 1.0-x2c_c%rAttr(index_x2ge_Sx_ocnfrac  ,ig) ! used as land
          camgrid%snowh(i,j) = (camgrid%xland(i,j) *x2c_c%rAttr(index_x2ge_Sx_snowhland  ,ig)  +camgrid%xice(i,j) * x2c_c%rAttr(index_x2ge_Sx_snowhice   ,ig))
           if(camgrid%xland(i,j).lt.0.5) then
            camgrid%xland(i,j)=0
           else
            camgrid%xland(i,j)=1
           endif
         
          ! from surface to underground 
          do k=1, camgrid%num_camgrid_soil_levels
            camgrid%soildepth(i,camgrid%num_camgrid_soil_levels-k+1,j)       =  x2c_c%rAttr(index_x2ge_Sx_soildepth(k),ig)  ! The unit is supposed as cm
            camgrid%soilthick(i,camgrid%num_camgrid_soil_levels-k+1,j)       = x2c_c%rAttr(index_x2ge_Sx_soilthick(k),ig)   !The unit is supposed as cm
            camgrid%soilt(i,camgrid%num_camgrid_soil_levels-k+1,j)   = x2c_c%rAttr(index_x2ge_Sx_soilt(k),ig)
            camgrid%soilm(i,camgrid%num_camgrid_soil_levels-k+1,j)   = x2c_c%rAttr(index_x2ge_Sx_soilm(k),ig) 
          enddo
           
	  do k = 1, camgrid%num_camgrid_levels
            camgrid%u3d(i,k,j) = x2c_c%rAttr(index_x2ge_Sx_u3d(k)     ,ig)
            camgrid%v3d(i,k,j) = x2c_c%rAttr(index_x2ge_Sx_v3d(k)     ,ig)
            camgrid%t3d(i,k,j) = x2c_c%rAttr(index_x2ge_Sx_t3d(k)     ,ig)
            camgrid%z3d(i,k,j) = x2c_c%rAttr(index_x2ge_Sx_z3d(k)     ,ig)            
            camgrid%p3d(i,k,j) = x2c_c%rAttr(index_x2ge_Sx_p3d(k)     ,ig)
	    camgrid%rh3d(i,k,j) = x2c_c%rAttr(index_x2ge_Sx_rh3d(k)     ,ig)  
            camgrid%qv3d(i,k,j)= x2c_c%rAttr(index_x2ge_Sx_qv3d(k),ig) 
            camgrid%qc3d(i,k,j)= x2c_c%rAttr(index_x2ge_Sx_qc3d(k),ig)
            camgrid%qi3d(i,k,j)= x2c_c%rAttr(index_x2ge_Sx_qi3d(k),ig)
            camgrid%taucldv3d(i,k,j) = x2c_c%rAttr(index_x2ge_Sx_taucldv3d(k)     ,ig)
            camgrid%taucldi3d(i,k,j) = x2c_c%rAttr(index_x2ge_Sx_taucldi3d(k)     ,ig)            
          end do  

           if( camgrid%ht(i,j) .lt.0)   camgrid%ht(i,j) = 0 ! it may be littler than zero in the ocean for the terrain
           do  k = 1, camgrid%num_camgrid_levels
              camgrid%z3d(i,k,j)  = camgrid%z3d(i,k,j)+camgrid%ht(i,j) ! the original height is the height above the surface not the sea level
           enddo

          ig=ig+1
         end do
       end do                                   

       ips=csx(1)
       ipe=cex(1)
       jps=csy(1)
       jpe=cey(1)
       kps=1
       kpe=camgrid%num_camgrid_levels       
       ids=1
       ide=camgrid%num_camgrid_lon
       jds=1
       jde=camgrid%num_camgrid_lat
       kds=1
       kde=camgrid%num_camgrid_levels
       call garther_camgrid(camgrid, ids, ide, jds, jde, kds, kde, &
                            camgrid%num_camgrid_levels, camgrid%num_camgrid_soil_levels, &
                            ips, ipe, jps, jpe, kps, kpe)

       if(first_sst) then
       call garther_camgrid_once(camgrid, ids, ide, jds, jde, kds, kde, &
                            camgrid%num_camgrid_levels,camgrid%num_camgrid_soil_levels, &
                            ips, ipe, jps, jpe, kps, kpe)
       allocate(xlon(wrfgrid%num_wrfgrid_lon,wrfgrid%num_wrfgrid_lat))
       allocate(xlat(wrfgrid%num_wrfgrid_lon,wrfgrid%num_wrfgrid_lat))
       allocate(templat(camgrid%num_camgrid_lat))
       allocate(templon(camgrid%num_camgrid_lon))
       do j=1,wrfgrid%num_wrfgrid_lat
       do i=1,wrfgrid%num_wrfgrid_lon
       xlon(i,j)=(i-1)*1.0_8+0.5_8
       end do
       end do
       do j=1,wrfgrid%num_wrfgrid_lat
       do i=1,wrfgrid%num_wrfgrid_lon
       xlat(i,j)=(j-1)*1.0_8-89.5_8
       end do       
       end do       
       templon(:)=1.0_8*camgrid%xlon(:,1)
       templat(:)=1.0_8*camgrid%xlat(1,:)
       call geatm_to_cam_mapping(templon, templat, camgrid%num_camgrid_lon, camgrid%num_camgrid_lat, &
            xlon, xlat,wrfgrid%num_wrfgrid_lon,wrfgrid%num_wrfgrid_lat)
       deallocate(xlat)
       deallocate(xlon)
       deallocate(templat)
       deallocate(templon)
        first_sst=.false.
       endif

       call cam_to_geatm(camgrid, wrfgrid)
       call wrfgrid_to_geatm(wrfgrid)

  end subroutine geatm_import_mct
!=============================================================================================================

  subroutine geatm_export_mct( x2ge_ge, camgrid, loop )
!-----------------------------------------------------------------------
! Arguments
!
     use geatm_vartype, only:csx,cex,csy,cey    
     TYPE(camgrid_c) :: camgrid
     type(mct_aVect)   , intent(inout) :: x2ge_ge
     integer :: loop
 end subroutine geatm_export_mct
!=============================================================================================================

  subroutine cam_to_geatm(camgrid, wrfgrid )
     use geatm_vartype, only:csx,cex,csy,cey,sx,ex,sy,ey

     TYPE(camgrid_c) :: camgrid
     TYPE(wrfgrid_c) :: wrfgrid

     ! Local variables  
     integer  :: i,j,k,ix,jy,km,local_index,global_index1,global_index2
     integer :: mids, mide, mjds, mjde, mkds, mkde, &
                mims, mime, mjms, mjme, mkms, mkme, &
                mips, mipe, mjps, mjpe, mkps, mkpe
     integer ::   ids, ide, jds, jde, kds, kde, &
                  ims, ime, jms, jme, kms, kme, &
                  ips, ipe, jps, jpe, kps, kpe 
     real(8),dimension(:,:,:),allocatable :: t3d_old
     real(8),dimension(:,:,:),allocatable :: t3d_new

       ! p3d 
       call cam_interpolate_to_geatm(camgrid, wrfgrid, 'p3d' )
       
       ! u3d              
       call cam_interpolate_to_geatm(camgrid, wrfgrid, 'u3d' )
       
       ! v3d              
       call cam_interpolate_to_geatm(camgrid, wrfgrid, 'v3d' )

       ! rh3d
       call cam_interpolate_to_geatm(camgrid, wrfgrid, 'rh3d' )

       ! qv3d
       call cam_interpolate_to_geatm(camgrid, wrfgrid, 'qv3d' )

       ! qc3d
       call cam_interpolate_to_geatm(camgrid, wrfgrid, 'qc3d' )

       ! qi3d
       call cam_interpolate_to_geatm(camgrid, wrfgrid, 'qi3d' )

       ! t3d
       call cam_interpolate_to_geatm(camgrid, wrfgrid, 't3d' )

       ! taucldv3d
       call cam_interpolate_to_geatm(camgrid, wrfgrid, 'taucldv3d' ) 

       ! taucldi3d
       call cam_interpolate_to_geatm(camgrid, wrfgrid, 'taucldi3d' )

       ! soilt
       call cam_interpolate_to_geatm_soil(camgrid, wrfgrid, 'soilt' )

       ! soilm
       call cam_interpolate_to_geatm_soil(camgrid, wrfgrid, 'soilm' )

       ips=sx(1)
       ipe=ex(1)
       jps=sy(1)
       jpe=ey(1)
       ids=1
       ide=wrfgrid%num_wrfgrid_lon
       jds=1
       jde=wrfgrid%num_wrfgrid_lat
       mips=csx(1)
       mipe=cex(1)
       mjps=csy(1)
       mjpe=cey(1)
       mids=1
       mide=camgrid%num_camgrid_lon
       mjds=1
       mjde=camgrid%num_camgrid_lat

       allocate(t3d_old(mids:mide,1:1,mjds:mjde))
       allocate(t3d_new(ips:ipe,1:1,jps:jpe))

       ! ps
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%ps(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%ps(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! snowh
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%snowh(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%snowh(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! xice
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%xice(i,j)*1.0_8
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%xice(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! rh2
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%rh2(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%rh2(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! q2
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%q2(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%q2(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! t2
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%t2(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%t2(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! u10
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%u10(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%u10(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! v10
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%v10(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%v10(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! pblh
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%pblh(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%pblh(i,j)=t3d_new(i,1,j)
       end do
       end do
       
       ! rmol
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%rmol(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%rmol(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! ust
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%ust(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%ust(i,j)=t3d_new(i,1,j)
       end do
       end do
      
       if(1.eq.0) then 
       ! no use of sst and tsk during the integration
       ! sst
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%sst(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%sst(i,j)=t3d_new(i,1,j)
       end do
       end do
      
       ! tsk
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%tsk(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%tsk(i,j)=t3d_new(i,1,j)
       end do
       end do
       end if

       ! rainncv
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%rainncv(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%rainncv(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! raincv
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%raincv(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%raincv(i,j)=t3d_new(i,1,j)
       end do
       end do
       
       ! swdown
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%swdown(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%swdown(i,j)=t3d_new(i,1,j)
       end do
       end do
       
       ! clflo
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%clflo(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%clflo(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! clfmi
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%clfmi(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%clfmi(i,j)=t3d_new(i,1,j)
       end do
       end do

       ! clfhi
       do j=mjds,mjde
       do i=mids,mide
       t3d_old(i,1,j)=camgrid%clfhi(i,j)
       end do
       end do
       call cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, 1, 1, &   
       mids, mide, mjds, mjde, 1, 1, &
       ips, ipe, jps, jpe, 1, 1, &
       ids, ide, jds, jde, 1, 1)
       do j=jps,jpe
       do i=ips,ipe
       wrfgrid%clfhi(i,j)=t3d_new(i,1,j)
       end do
       end do

      deallocate(t3d_old)
      deallocate(t3d_new)

    end subroutine cam_to_geatm
    
!=============================================================================================================

    subroutine cam_interpolate_to_geatm(camgrid, wrfgrid, symbol )
     use geatm_vartype, only:csx,cex,csy,cey,sx,ex,sy,ey

     TYPE(camgrid_c) :: camgrid
     TYPE(wrfgrid_c) :: wrfgrid
     character(len=*) :: symbol
     
     ! Local variables  
     integer  :: i,j,k,ix,jy,kz,km,local_index,global_index1,global_index2
     real(8) :: s, wweight
     real(8),dimension(:,:,:),allocatable:: p3d, t3d, w3d, t3d_new, t3d_int 
     integer ::   ids, ide, jds, jde, kds, kde, &
                  ips, ipe, jps, jpe, kps, kpe 
                   
      ips=sx(1)
      ipe=ex(1)
      jps=sy(1)
      jpe=ey(1)

      allocate(p3d(1,1:camgrid%num_camgrid_levels,1))
      allocate(t3d(1,1:camgrid%num_camgrid_levels,1))      
      allocate(w3d(1,1:wrfgrid%num_wrfgrid_levels,1))
      allocate(t3d_new(1,1:wrfgrid%num_wrfgrid_levels,1))
      allocate(t3d_int(ips:ipe,1:wrfgrid%num_wrfgrid_levels,jps:jpe))

       global_index1 = 0
       t3d_int = 0.0_8
       do jy=jps,jpe
       do ix=ips,ipe

        do kz=1,wrfgrid%num_wrfgrid_levels
        w3d(1,kz,1) = wrfgrid%z3d(ix,kz,jy)
        end do

        local_index=0
        local_index=cam_local_points(ix,jy)
        if(local_index.gt.0) then

        do km=1,local_index
           global_index1=global_index1+1
           i=remap_cami(global_index1)
           j=remap_camj(global_index1)
           wweight=cam_weight(global_index1)
         
          select case(trim(adjustl(symbol)))
          ! p3d
          case('p3d')
            do kz=1,camgrid%num_camgrid_levels
             t3d(1,kz,1) = camgrid%p3d(i,kz,j)
            end do
          ! u3d
          case('u3d')
            do kz=1,camgrid%num_camgrid_levels
             t3d(1,kz,1) = camgrid%u3d(i,kz,j)
            end do
          ! v3d
          case('v3d')
            do kz=1,camgrid%num_camgrid_levels
             t3d(1,kz,1) = camgrid%v3d(i,kz,j)
            end do
          ! t3d
          case('t3d')
            do kz=1,camgrid%num_camgrid_levels
             t3d(1,kz,1) = camgrid%t3d(i,kz,j)
            end do
          ! qv3d
          case('qv3d')
            do kz=1,camgrid%num_camgrid_levels
             t3d(1,kz,1) = camgrid%qv3d(i,kz,j)
            end do
          ! qc3d
          case('qc3d')
            do kz=1,camgrid%num_camgrid_levels
             t3d(1,kz,1) = camgrid%qc3d(i,kz,j)
            end do
          ! qi3d
          case('qi3d')
            do kz=1,camgrid%num_camgrid_levels
             t3d(1,kz,1) = camgrid%qi3d(i,kz,j)
            end do 
          ! rh3d
          case('rh3d')
            do kz=1,camgrid%num_camgrid_levels
             t3d(1,kz,1) = camgrid%rh3d(i,kz,j)
            end do
          ! taucldv3d
          case('taucldv3d')
            do kz=1,camgrid%num_camgrid_levels
             t3d(1,kz,1)=camgrid%taucldv3d(i,kz,j)
            end do
          ! taucldi3d
          case('taucldi') 
            do kz=1,camgrid%num_camgrid_levels
             t3d(1,kz,1)=camgrid%taucldi3d(i,kz,j)
            end do
         end select       

         do kz=1,camgrid%num_camgrid_levels
         p3d(1,kz,1) = camgrid%z3d(i,kz,j)
         end do

         call interpolate_to_pressure_levels(1,camgrid%num_camgrid_levels &
               ,1,1,wrfgrid%num_wrfgrid_levels &
               ,p3d,w3d,t3d,t3d_new)
          
           do kz=1,wrfgrid%num_wrfgrid_levels
             t3d_int(ix,kz,jy) = t3d_int(ix,kz,jy)+t3d_new(1,kz,1)*wweight
           end do
      
       enddo
       end if ! local index
    
          select case(trim(adjustl(symbol)))
          ! p3d
          case('p3d')
           do kz=1,wrfgrid%num_wrfgrid_levels
            wrfgrid%p3d(ix,kz,jy) = t3d_int(ix,kz,jy)
           end do
          ! u3d
          case('u3d')
           do kz=1,wrfgrid%num_wrfgrid_levels
             wrfgrid%u3d(ix,kz,jy) = t3d_int(ix,kz,jy)
           end do 
          ! v3d
          case('v3d')
           do kz=1,wrfgrid%num_wrfgrid_levels
            wrfgrid%v3d(ix,kz,jy) = t3d_int(ix,kz,jy)
           end do
          ! t3d
          case('t3d')
           do kz=1,wrfgrid%num_wrfgrid_levels
            wrfgrid%t3d(ix,kz,jy) = t3d_int(ix,kz,jy)
           end do
          ! qv3d
          case('qv3d')
           do kz=1,wrfgrid%num_wrfgrid_levels
             wrfgrid%qv3d(ix,kz,jy) = t3d_int(ix,kz,jy)
           end do
          ! qc3d
          case('qc3d')
           do kz=1,wrfgrid%num_wrfgrid_levels
            wrfgrid%qc3d(ix,kz,jy) = t3d_int(ix,kz,jy)
           end do
          ! qi3d
          case('qi3d')
           do kz=1,wrfgrid%num_wrfgrid_levels
            wrfgrid%qi3d(ix,kz,jy) = t3d_int(ix,kz,jy)
           end do
          ! rh3d
          case('rh3d')
           do kz=1,wrfgrid%num_wrfgrid_levels
            wrfgrid%rh3d(ix,kz,jy) = t3d_int(ix,kz,jy)
           end do
          ! taucldv3d
          case('taucldv3d')
           do kz=1,wrfgrid%num_wrfgrid_levels
            wrfgrid%taucldv3d(ix,kz,jy) = t3d_int(ix,kz,jy)
           end do
          ! taucldi3d
          case('taucldi') 
           do kz=1,wrfgrid%num_wrfgrid_levels
             wrfgrid%taucldi3d(ix,kz,jy) = t3d_int(ix,kz,jy)
           end do
         end select       
       
      enddo 
      enddo 

      deallocate(p3d)
      deallocate(t3d)      
      deallocate(w3d)
      deallocate(t3d_new)
      deallocate(t3d_int)

      end subroutine cam_interpolate_to_geatm

!=============================================================================================================
    subroutine cam_interpolate_to_geatm_soil(camgrid, wrfgrid, symbol )
     use geatm_vartype, only:csx,cex,csy,cey,sx,ex,sy,ey

     TYPE(camgrid_c) :: camgrid
     TYPE(wrfgrid_c) :: wrfgrid
     character(len=*) :: symbol
     
     ! Local variables  
     integer  :: i,j,k,ix,jy,km,local_index,global_index1,global_index2
     real(8) :: s, wweight
     real(8),dimension(:,:,:),allocatable:: p3d, t3d, w3d, t3d_new,t3d_int 
     integer ::   ids, ide, jds, jde, kds, kde, &
                  ips, ipe, jps, jpe, kps, kpe 

      ips=sx(1)
      ipe=ex(1)
      jps=sy(1)
      jpe=ey(1)

      allocate(p3d(1,1:camgrid%num_camgrid_soil_levels,1))
      allocate(t3d(1,1:camgrid%num_camgrid_soil_levels,1))      
      allocate(w3d(1,1:wrfgrid%num_wrfgrid_soil_levels,1))
      allocate(t3d_new(1,1:wrfgrid%num_wrfgrid_soil_levels,1))
      allocate(t3d_int(ips:ipe,1:wrfgrid%num_wrfgrid_soil_levels,jps:jpe))

       global_index1 = 0
       t3d_int = 0
       do jy=jps,jpe
       do ix=ips,ipe

         do k=1,wrfgrid%num_wrfgrid_soil_levels
           w3d(1,k,1) = wrfgrid%soildepth(ix,wrfgrid%num_wrfgrid_soil_levels-k+1,jy)  ! use m
         enddo

        local_index=0
        local_index=cam_local_points(ix,jy)
        if(local_index.gt.0) then
        do km=1,local_index
           global_index1=global_index1+1
           i=remap_cami(global_index1)
           j=remap_camj(global_index1)
           wweight=cam_weight(global_index1)

         select case(trim(adjustl(symbol)))
         ! soilt
         case('soilt')
            do k=1,camgrid%num_camgrid_soil_levels
             t3d(1,k,1) = camgrid%soilt(i,k,j)
            end do
         ! soilm
         case('soilm')
            do k=1,camgrid%num_camgrid_soil_levels
             t3d(1,:,1) = camgrid%soilm(i,:,j)
            end do
         end select

         do k=1,camgrid%num_camgrid_soil_levels
           p3d(1,k,1) = camgrid%soildepth(i,k,j)
         end do
         call interpolate_to_pressure_levels(1,camgrid%num_camgrid_soil_levels &
               ,1,1,wrfgrid%num_wrfgrid_soil_levels &
               ,p3d,w3d,t3d,t3d_new)

         do k=1,wrfgrid%num_wrfgrid_soil_levels      
          t3d_int(ix,k,jy) = t3d_int(ix,k,jy)+t3d_new(1,k,1)*wweight
         end do 

       enddo
       end if ! local index
    
          ! sort to from the surfce to the underground
          do k=1,wrfgrid%num_wrfgrid_soil_levels/2 
           s = t3d_int(ix,k,jy)
           t3d_int(ix,k,jy) = t3d_int(ix,wrfgrid%num_wrfgrid_soil_levels-k+1,jy)
           t3d_int(ix,wrfgrid%num_wrfgrid_soil_levels-k+1,jy) = t3d_int(ix,k,jy)
          end do

         select case(trim(adjustl(symbol)))
         ! soilt
         case('soilt')
           do k=1,wrfgrid%num_wrfgrid_soil_levels
            wrfgrid%soilt(ix,k,jy) = t3d_int(ix,k,jy)
           end do
         ! soilm
         case('soilm')
           do k=1,wrfgrid%num_wrfgrid_soil_levels
            wrfgrid%soilm(ix,k,jy) = t3d_int(ix,k,jy)
           end do
         end select
       
      enddo 
      enddo 

      deallocate(p3d)
      deallocate(t3d)      
      deallocate(w3d)
      deallocate(t3d_new)
      deallocate(t3d_int)

      end subroutine cam_interpolate_to_geatm_soil
!=============================================================================================================

    subroutine cam_horizontal_interpolate_to_geatm(t3d_old,t3d_new, &
       mips, mipe, mjps, mjpe, mkps, mkpe, &   
       mids, mide, mjds, mjde, mkds, mkde, &
       ips, ipe, jps, jpe, kps, kpe, &
       ids, ide, jds, jde, kds, kde)

     integer ::  mids, mide, mjds, mjde, mkds, mkde, &
                  mips, mipe, mjps, mjpe, mkps, mkpe, & 
                  ids, ide, jds, jde, kds, kde, &
                  ips, ipe, jps, jpe, kps, kpe 
     real(8),dimension(mids:mide,1:1,mjds:mjde) :: t3d_old                   
     real(8),dimension(ips:ipe,1:1,jps:jpe) :: t3d_new
     
     ! Local variables  
     integer  :: i,j,k,ix,jy,km,local_index,global_index1,global_index2
     real(8) :: s, wweight 


       t3d_new = 0
       global_index1 = 0
       do jy=jps,jpe
       do ix=ips,ipe

        local_index=0
        local_index=cam_local_points(ix,jy)
        if(local_index.gt.0) then
        do km=1,local_index
           global_index1=global_index1+1
           i=remap_cami(global_index1)
           j=remap_camj(global_index1)
           wweight=cam_weight(global_index1)
           t3d_new(ix,1,jy) = t3d_new(ix,1,jy)+t3d_old(i,1,j)*wweight
        enddo
        end if ! local index
       
      enddo 
      enddo 

      end subroutine cam_horizontal_interpolate_to_geatm
      
!=============================================================================================================      
     subroutine wrfgrid_to_geatm(wrfgrid )
      use geatm_vartype, only: q2, t2

     TYPE(wrfgrid_c) :: wrfgrid

     ! Local variables  
     integer  :: i,j,k,ix,jy,km,kl,i0
       
       do k=1,wrfgrid%num_wrfgrid_levels
        i0=ip3mem(k,1)
        kl=wrfgrid%num_wrfgrid_levels-k+1 ! from the surface to upper troposphere
          do j= sy(1),ey(1)
          do i= sx(1),ex(1)
            km=i0+(ex(1)-sx(1)+3)*(j-sy(1)+1)+i-sx(1)+1
            plev(km)=real(wrfgrid%p3d(i,kl,j)/100.0) ! from Pa to hPa
            h(km)=real(wrfgrid%z3d(i,kl,j)/1000.0)  ! from m to km
            t(km)=real(wrfgrid%t3d(i,kl,j))
            u(km)=real(wrfgrid%u3d(i,kl,j))
            v(km)=real(wrfgrid%v3d(i,kl,j)) 
            qvapor(km)=real(wrfgrid%qv3d(i,kl,j)) 
            clw(km)=real(wrfgrid%qc3d(i,kl,j)) 
            rnw(km)=real(wrfgrid%qi3d(i,kl,j))
            rh1(km)=real(wrfgrid%rh3d(i,kl,j))
            if(rh1(km).gt.100.0) then
            rh1(km)=100.0
            elseif(rh1(km).lt.0.0) then
            rh1(km)=0.0
            endif
            taucldc(km)=real(wrfgrid%taucldv3d(i,kl,j))
            taucldi(km)=real(wrfgrid%taucldi3d(i,kl,j))
          end do
          end do
       end do  

       i0=1
       do k=1,wrfgrid%num_wrfgrid_soil_levels
          do j= sy(1),ey(1)
          do i= sx(1),ex(1)
            km=i0+(ex(1)-sx(1)+3)*(j-sy(1)+1)+i-sx(1)+1
            soilt(km)=real(wrfgrid%soilt(i,k,j))
            soilrh(km)=real(wrfgrid%soilm(i,k,j))
          end do
          end do
        i0=i0+(nx(1)+2)*(ny(1)+2)
       end do
       
       i0=ip2mem(1)
       do j= sy(1),ey(1)
       do i= sx(1),ex(1)
           km=i0+(ex(1)-sx(1)+3)*(j-sy(1)+1)+i-sx(1)+1
           q2(km)=real(wrfgrid%q2(i,j))
           t2(km)=real(wrfgrid%t2(i,j))
           u10(km)=real(wrfgrid%u10(i,j))
           v10(km)=real(wrfgrid%v10(i,j))
           pbl_hgt(km)=real(wrfgrid%pblh(i,j))
           rmol(km)=real(wrfgrid%rmol(i,j))
           ust(km)=real(wrfgrid%ust(i,j))
           psfc(km)=real(wrfgrid%ps(i,j))
           fsnow(km)=real(wrfgrid%snowh(i,j))
           fice(km)=real(wrfgrid%xice(i,j))
           rhsfc(km)=real(wrfgrid%rh2(i,j))
           if(rhsfc(km).gt.100) then
            rhsfc(km)=100.0
           elseif(rhsfc(km).lt.0) then
            rhsfc(km)=0.0
           end if
           rainnon(km)=real(wrfgrid%rainncv(i,j)*3600*100)  ! from m/s to cm/h
           raincon(km)=real(wrfgrid%raincv(i,j)*3600*100)   ! from m/s to cm/h
           swdown(km)=real(wrfgrid%swdown(i,j))
           clflo(km)=real(wrfgrid%clflo(i,j))
           clfmi(km)=real(wrfgrid%clfmi(i,j))
           clfhi(km)=real(wrfgrid%clfhi(i,j))
        end do
       end do
          
    end subroutine wrfgrid_to_geatm
!=============================================================================================================

   subroutine geatm_to_cam_mapping(templon, templat, lonlen, latlen, xlon, xlat, mlon, mlat)
     use geatm_vartype, only : csx,cex,csy,cey

     integer,intent(in) :: latlen, lonlen, mlon, mlat
     real*8,dimension(1:latlen),intent(inout) :: templat  ! source lat
     real*8,dimension(1:lonlen),intent(inout) :: templon  ! source lon
     real*8,dimension(1:mlon,1:mlat),intent(inout) :: xlat  ! target lat
     real*8,dimension(1:mlon,1:mlat),intent(inout) :: xlon  ! target lon

     integer :: lchnk, ncols, mm, n
     integer :: i,j,k,ix,jy,km,local_index,global_index
     real*8 :: s,ss,sn,se,sw,sa
     real*8 :: dlondeg,dlatdeg
     real*8 :: pi=3.1415926_8

     real*8,dimension(:,:),allocatable:: ws,we,wn,ww,camarea
     real*8,dimension(:),allocatable:: cmipx,cmipy,cmipa

     integer :: mids, mide, mjds, mjde, mkds, mkde, &
                mims, mime, mjms, mjme, mkms, mkme, &
                mips, mipe, mjps, mjpe, mkps, mkpe
     integer ::   ids, ide, jds, jde, kds, kde, &
                  ims, ime, jms, jme, kms, kme, &
                  ips, ipe, jps, jpe, kps, kpe

       mips=sx(1)
       mipe=ex(1)
       mjps=sy(1)
       mjpe=ey(1)
       mids=1
       mide=wrfgrid%num_wrfgrid_lon
       mjds=1
       mjde=wrfgrid%num_wrfgrid_lat
       ips=csx(1)
       ipe=cex(1)
       jps=csy(1)
       jpe=cey(1)
       ids=1
       ide=camgrid%num_camgrid_lon
       jds=1
       jde=camgrid%num_camgrid_lat
     
       ! source
       allocate(ww(lonlen,latlen))
       allocate(we(lonlen,latlen))
       allocate(ws(lonlen,latlen))
       allocate(wn(lonlen,latlen))
       allocate(camarea(mlon,mlat))
       allocate(cam_local_points(mlon,mlat))

       allocate(cmipx(cam_to_geatm_points))
       allocate(cmipy(cam_to_geatm_points))
       allocate(cmipa(cam_to_geatm_points))

       dlondeg=templon(2)-templon(1)
       if (templat(2)-templat(1).gt.0.0) then
        dlatdeg=templat(2)-templat(1)
       else
        dlatdeg=templat(1)-templat(2)
       end if

       do j=1,latlen
        do i=1,lonlen                 
          if(templon(i).lt.0) templon(i)=templon(i)+360.0_8
             we(i,j)=templon(i)+dlondeg/2
             ww(i,j)=templon(i)-dlondeg/2
          if(ww(i,j).lt.0)  then  ! cross the 0 longitude
             ww(i,j)=ww(i,j)+360.0_8
             we(i,j)=we(i,j)+360.0_8
          endif
          if (templat(2)-templat(1).gt.0.0) then
          if(j.gt.1.and.j.lt.latlen) then
           wn(i,j)=(templat(j)+templat(j+1))/2
           ws(i,j)=(templat(j)+templat(j-1))/2
          end if
          if(j.eq.1) then
           wn(i,j)=(templat(j)+templat(2))/2
           ws(i,j)=-90.0_8
          end if
          if(j.eq.latlen) then
           wn(i,j)=90.0_8
           ws(i,j)=(templat(j)+templat(j-1))/2
          end if
          else
          if(j.gt.1.and.j.lt.latlen) then
           wn(i,j)=(templat(j)+templat(j-1))/2
           ws(i,j)=(templat(j)+templat(j+1))/2
          end if
          if(j.eq.1) then
           ws(i,j)=(templat(j)+templat(2))/2
           wn(i,j)=90.0_8
          end if
          if(j.eq.latlen) then
           ws(i,j)=-90.0_8
           wn(i,j)=(templat(j)+templat(j-1))/2
          end if
          endif
          if(ws(i,j).lt.-90.0_8)  ws(i,j)=-90.0_8
          if(wn(i,j).gt.90.0_8)  wn(i,j)=90.0_8
          
        end do
       end do  
      
       global_index=0
         do jy=mjps,mjpe
           do ix=mips,mipe
              ax=ix+1 
              if(ax.gt.mide) ax=1  
              bx=ix-1 
              if(bx.lt.1) bx=mide  

              ay=jy+1 
              if(ay.gt.mjde) ay=1   
              by=jy-1  
              if(by.lt.1) by=mjde

              ! the target
              if(ix.eq.1) then
                 se=(xlon(ax,jy)+xlon(ix,jy))/2+360
                 sw=(xlon(mide,jy)+360)/2
              elseif(ix.eq.mide) then
                 se=(xlon(ix,jy)+360)/2
                 sw=(xlon(bx,jy)+xlon(ix,jy))/2
              else
                 se=(xlon(ax,jy)+xlon(ix,jy))/2
                 sw=(xlon(bx,jy)+xlon(ix,jy))/2    
              endif

              if(jy.eq.1) then
                 ss=-90
                 sn=(xlat(ix,ay)+xlat(ix,jy))/2
              elseif(jy.eq.mjde) then
                 ss=(xlat(ix,by)+xlat(ix,jy))/2
                 sn=90                    
              else
                 ss=(xlat(ix,by)+xlat(ix,jy))/2
                 sn=(xlat(ix,ay)+xlat(ix,jy))/2     
              endif
              s=sin(sn*pi/180)-sin(ss*pi/180)  
              camarea(ix,jy)=s*(se-sw)

           ! source to target
           local_index=0
           sa=0
           do j=1,latlen
           do i=1,lonlen

            ! case 1 -case 9 and case 10-1,2,3 and case 10-5,6,7
            ! are the templat and templon finer than xlat and xlon

            ! case 1
            if(wn(i,j).le.sn.and.ws(i,j).ge.ss.and.ww(i,j).ge.sw.and.we(i,j).le.se) then
              local_index=local_index+1
              cmipx(local_index)=i
              cmipy(local_index)=j
              cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ws(i,j)*pi/180))*(we(i,j)-ww(i,j))       
              sa=sa+cmipa(local_index)
              goto 999
            endif

            ! case 2
            if(wn(i,j).le.sn.and.ws(i,j).ge.ss.and.ww(i,j).le.sw.and.&
               we(i,j).le.se.and.we(i,j).ge.sw) then
               local_index=local_index+1
               cmipx(local_index)=i
               cmipy(local_index)=j
               cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ws(i,j)*pi/180))*(we(i,j)-sw)
               sa=sa+cmipa(local_index)
               goto 999
            endif

            ! case 3
            if(wn(i,j).le.sn.and.ws(i,j).ge.ss.and.ww(i,j).ge.sw.and.&
               ww(i,j).le.se.and.we(i,j).ge.se) then
               local_index=local_index+1
               cmipx(local_index)=i
               cmipy(local_index)=j
               cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ws(i,j)*pi/180))*(se-ww(i,j))
               sa=sa+cmipa(local_index)
               goto 999 
            endif

            ! case4
            if(wn(i,j).ge.sn.and.ws(i,j).ge.ss.and.ws(i,j).le.sn.and.&
               ww(i,j).ge.sw.and.we(i,j).le.se) then 
               local_index=local_index+1 
               cmipx(local_index)=i 
               cmipy(local_index)=j 
               cmipa(local_index)=(sin(sn*pi/180)-sin(ws(i,j)*pi/180))*(we(i,j)-ww(i,j))
               sa=sa+cmipa(local_index)
               goto 999
            endif

            ! case5
            if(wn(i,j).le.sn.and.wn(i,j).ge.ss.and.ws(i,j).le.ss.and.&
               ww(i,j).ge.sw.and.we(i,j).le.se) then
               local_index=local_index+1
               cmipx(local_index)=i
               cmipy(local_index)=j
               cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ss*pi/180))*(we(i,j)-ww(i,j))
               sa=sa+cmipa(local_index)
               goto 999
            endif 

            ! case6
            if(wn(i,j).ge.sn.and.ws(i,j).ge.ss.and.ws(i,j).le.sn.and.&
               we(i,j).ge.se.and.ww(i,j).ge.sw.and.ww(i,j).le.se) then
               local_index=local_index+1
               cmipx(local_index)=i
               cmipy(local_index)=j
               cmipa(local_index)=(sin(sn*pi/180)-sin(ws(i,j)*pi/180))*(se-ww(i,j))
               sa=sa+cmipa(local_index)
               goto 999
            endif

            ! case 7
            if(wn(i,j).ge.sn.and.ws(i,j).ge.ss.and.ws(i,j).le.sn.and.&
               we(i,j).le.se.and.we(i,j).ge.sw.and.ww(i,j).le.sw) then
               local_index=local_index+1
               cmipx(local_index)=i
               cmipy(local_index)=j
               cmipa(local_index)=(sin(sn*pi/180)-sin(ws(i,j)*pi/180))*(we(i,j)-sw)
               sa=sa+cmipa(local_index)
               goto 999
            endif

            ! case 8
            if(wn(i,j).le.sn.and.wn(i,j).ge.ss.and.ws(i,j).le.ss.and.&
               we(i,j).le.se.and.we(i,j).ge.sw.and.ww(i,j).le.sw) then
               local_index=local_index+1 
               cmipx(local_index)=i
               cmipy(local_index)=j 
               cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ss*pi/180))*(we(i,j)-sw)
               sa=sa+cmipa(local_index)
               goto 999
            endif

            ! case 9
            if(wn(i,j).le.sn.and.wn(i,j).ge.ss.and.ws(i,j).le.ss.and.&
               we(i,j).ge.se.and.ww(i,j).ge.sw.and.ww(i,j).le.se) then
               local_index=local_index+1  
               cmipx(local_index)=i 
               cmipy(local_index)=j  
               cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ss*pi/180))*(se-ww(i,j))
               sa=sa+cmipa(local_index)
               goto 999  
            endif
                   
            ! case 10,  templon doesn't across the 0 degree but cam's grid across the 0 longitude
            if((ww(i,j)+360-sw).ge.0.and.(ww(i,j)+360-se).le.0) then

             if((we(i,j)+360-se).le.0) then
              ! case 10-1
              if(wn(i,j).le.sn.and.wn(i,j).ge.ss.and.ws(i,j).le.ss) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ss*pi/180))*(we(i,j)-ww(i,j))
                 sa=sa+cmipa(local_index)
                 goto 999
              endif
              ! case 10-2
              if(wn(i,j).le.sn.and.ws(i,j).gt.ss) then
                 local_index=local_index+1
                 cmipx(local_index)=i 
                 cmipy(local_index)=j 
                 cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ws(i,j)*pi/180))*(we(i,j)-ww(i,j))
                 sa=sa+cmipa(local_index)
                 goto 999
              endif
              ! case 10-3
              if(wn(i,j).gt.sn.and.ws(i,j).gt.ss.and.ws(i,j).le.sn) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ws(i,j)*pi/180))*(we(i,j)-ww(i,j))
                 sa=sa+cmipa(local_index)
                 goto 999
              endif
              ! case 10-4
              if(wn(i,j).gt.sn.and.ws(i,j).lt.ss) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ss*pi/180))*(we(i,j)-ww(i,j))
                 sa=sa+cmipa(local_index)
                 goto 999
              endif
             end if

             if((we(i,j)+360-se).gt.0) then
              ! case 10-5
              if(wn(i,j).le.sn.and.wn(i,j).ge.ss.and.ws(i,j).le.ss) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ss*pi/180))*(se-ww(i,j)-360)
                 sa=sa+cmipa(local_index)
                 goto 999
              endif
              ! case 10-6
              if(wn(i,j).le.sn.and.ws(i,j).gt.ss) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ws(i,j)*pi/180))*(se-ww(i,j)-360)
                 sa=sa+cmipa(local_index)
                 goto 999
              endif
              ! case 10-7
              if(wn(i,j).ge.sn.and.ws(i,j).gt.ss.and.ws(i,j).le.sn) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ws(i,j)*pi/180))*(se-ww(i,j)-360)
                 sa=sa+cmipa(local_index)
                 goto 999
              endif
              ! case 10-8
              if(wn(i,j).ge.sn.and.ws(i,j).le.ss) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ss*pi/180))*(se-ww(i,j)-360)
                 sa=sa+cmipa(local_index)
                 goto 999
              ENDIF
             end if

            end if

             ! case 11
             if(wn(i,j).ge.sn.and.ws(i,j).le.ss.and.ww(i,j).le.sw.and.we(i,j).ge.se) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ss*pi/180))*(se-sw)
                 sa=sa+cmipa(local_index)
                 goto 999
             ENDIF

             ! case 12
             if(wn(i,j).ge.sn.and.ws(i,j).le.ss.and.ww(i,j).le.se.and.ww(i,j).ge.sw.and.&
                we(i,j).ge.se) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ss*pi/180))*(se-ww(i,j))
                 sa=sa+cmipa(local_index)
                 goto 999
             ENDIF

             ! case 13
             if(wn(i,j).ge.sn.and.ws(i,j).le.ss.and.ww(i,j).le.sw.and.we(i,j).ge.sw.and.&
                we(i,j).le.se) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ss*pi/180))*(we(i,j)-sw)
                 sa=sa+cmipa(local_index)
                 goto 999
             ENDIF

             ! case 14
             if(wn(i,j).gt.sn.and.ws(i,j).ge.ss.and.ws(i,j).le.sn.and. &
                ww(i,j).le.sw.and.we(i,j).ge.se) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ws(i,j)*pi/180))*(se-sw)
                 sa=sa+cmipa(local_index)
                 goto 999
             ENDIF

             ! case 15
             if(wn(i,j).le.sn.and.wn(i,j).ge.ss.and.ws(i,j).le.ss.and. &
                ww(i,j).le.sw.and.we(i,j).ge.se) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ss*pi/180))*(se-sw)
                 sa=sa+cmipa(local_index)
                 goto 999
             ENDIF

             ! case 16
             if(wn(i,j).ge.sn.and.ws(i,j).le.ss.and. &
                ww(i,j).ge.sw.and.we(i,j).le.se) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ss*pi/180))*(we(i,j)-ww(i,j))
                 sa=sa+cmipa(local_index)
                 goto 999
             ENDIF

             ! case 17
             if(wn(i,j).le.sn.and.ws(i,j).ge.ss.and. &
                ww(i,j).le.sw.and.we(i,j).ge.se) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ws(i,j)*pi/180))*(se-sw)
                 sa=sa+cmipa(local_index)
                 goto 999
             ENDIF

             ! case 18, the original grid across 0, the target doesn't across 0
             if(we(i,j).gt.360) then
                if(we(i,j)-360.ge.sw.and.(we(i,j)-360).le.se) then               
                 ! case 18-1
                 if(wn(i,j).le.sn.and.wn(i,j).ge.ss.and.ws(i,j).le.ss) then                 
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ss*pi/180))*(we(i,j)-360-sw)
                 sa=sa+cmipa(local_index)
                 goto 999
                 end if
                 ! case 18-2
                 if(wn(i,j).ge.sn.and.ws(i,j).le.ss) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ss*pi/180))*(we(i,j)-360-sw)
                 sa=sa+cmipa(local_index)
                 goto 999
                 end if
                 ! case 18-3
                 if(wn(i,j).ge.sn.and.ws(i,j).ge.ss.and.ws(i,j).le.sn) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ws(i,j)*pi/180))*(we(i,j)-360-sw)
                 sa=sa+cmipa(local_index)
                 goto 999
                 end if
                endif 
                if(we(i,j)-360.ge.se) then
                 ! case 18-4
                 if(wn(i,j).le.sn.and.wn(i,j).ge.ss.and.ws(i,j).le.ss) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(wn(i,j)*pi/180)-sin(ss*pi/180))*(se-sw)
                 sa=sa+cmipa(local_index)
                 goto 999
                 end if
                 ! case 18-5
                 if(wn(i,j).ge.sn.and.ws(i,j).le.ss) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ss*pi/180))*(se-sw)
                 sa=sa+cmipa(local_index)
                 goto 999
                 end if
                 ! case 18-6
                 if(wn(i,j).ge.sn.and.ws(i,j).ge.ss.and.ws(i,j).le.sn) then
                 local_index=local_index+1
                 cmipx(local_index)=i
                 cmipy(local_index)=j
                 cmipa(local_index)=(sin(sn*pi/180)-sin(ws(i,j)*pi/180))*(se-sw)
                 sa=sa+cmipa(local_index)
                 goto 999
                 end if
                endif
             ENDIF

999               continue
                enddo
              enddo

              s=abs(sa-camarea(ix,jy))/camarea(ix,jy)
              if(s.gt.0.0001_8) then
               print *, s,local_index
               print *, ss,sn,sw,se,camarea(ix,jy)
              end if

              sa=0.0
              cam_local_points(ix,jy)=local_index
              do i=1,local_index
              if(s.gt.0.0001_8) then
               print *, ws(cmipx(i),cmipy(i)),wn(cmipx(i),cmipy(i)),ww(cmipx(i),cmipy(i)),we(cmipx(i),cmipy(i)),cmipa(i)
              end if 
              global_index=global_index+1
              remap_cami(global_index)=cmipx(i)
              remap_camj(global_index)=cmipy(i)
              cam_weight(global_index)=cmipa(i)/camarea(ix,jy)
              sa=sa+cam_weight(global_index)
              enddo
        enddo
        enddo

         deallocate(ws)
         deallocate(wn)
         deallocate(we)
         deallocate(ww)
         deallocate(cmipx)
         deallocate(cmipy)
         deallocate(cmipa)
         deallocate(camarea)

  end subroutine geatm_to_cam_mapping
!===============================================================================
   subroutine garther_camgrid_once(grid, ids, ide, jds, jde, kds, kde, &
                              num_metgrid_levels, num_metgrid_soil_levels, &
                              ips, ipe, jps, jpe, kps, kpe)
   use geatm_vartype, only : local_com
   include "mpif.h"

   type(camgrid_c)::grid
   integer,intent(in)::ids, ide, jds, jde, kds, kde,  &   
                       ips, ipe, jps, jpe, kps, kpe,  &
                       num_metgrid_levels, num_metgrid_soil_levels 
                               
   real(8), dimension(:,:,:), allocatable :: patch_array
   real(8), dimension(:,:,:), allocatable :: domain_array
   integer :: i, j, k, mpi_ierr
   
     allocate(patch_array(ips:ipe,1:num_metgrid_soil_levels,jps:jpe))
     allocate(domain_array(ids:ide,1:num_metgrid_soil_levels,jds:jde))

     ! soilthick
      do j=jps, jpe
       do k=1,num_metgrid_soil_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%soilthick(i,k,j)
        enddo
       enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_soil_levels, jps, jpe, &
                              domain_array, ids, ide, 1, num_metgrid_soil_levels, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_soil_levels, MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%soilthick=domain_array      

      ! soildepth
      do j=jps, jpe
       do k=1,num_metgrid_soil_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%soildepth(i,k,j)
        enddo
       enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_soil_levels, jps, jpe, & 
                              domain_array, ids, ide, 1, num_metgrid_soil_levels, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_soil_levels, MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%soildepth=domain_array
      
      deallocate(patch_array)
      deallocate(domain_array)
      
      allocate(patch_array(ips:ipe,1:1,jps:jpe))
      allocate(domain_array(ids:ide,1:1,jds:jde))
      
      ! xlat
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%xlat(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide   
         grid%xlat(i,j)=domain_array(i,1,j)
        enddo
      enddo
      
      ! xlon
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%xlon(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                           
         grid%xlon(i,j)=domain_array(i,1,j)
        enddo
      enddo

      deallocate(patch_array)
      deallocate(domain_array)

   end subroutine garther_camgrid_once
!===============================================================================

   subroutine garther_camgrid(grid, ids, ide, jds, jde, kds, kde, &
                              num_metgrid_levels, num_metgrid_soil_levels, &
                              ips, ipe, jps, jpe, kps, kpe)
   use geatm_vartype, only : local_com
   include "mpif.h"

   type(camgrid_c)::grid
   integer,intent(in)::ids, ide, jds, jde, kds, kde,  &   
                       ips, ipe, jps, jpe, kps, kpe,  &
                       num_metgrid_levels, num_metgrid_soil_levels 
                               
   real(8), dimension(:,:,:), allocatable :: patch_array
   real(8), dimension(:,:,:), allocatable :: domain_array
   integer :: i, j, k, mpi_ierr
   
      allocate(patch_array(ips:ipe,1:num_metgrid_levels,jps:jpe))
      allocate(domain_array(ids:ide,1:num_metgrid_levels,jds:jde))

      ! p3d
      do j=jps, jpe
       do k=1,num_metgrid_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%p3d(i,k,j)
        enddo
       enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1,num_metgrid_levels,jps, jpe, &
                              domain_array, ids, ide, 1,num_metgrid_levels,jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_levels, MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%p3d=domain_array
      call mpi_barrier(local_com, mpi_ierr)

      ! u3d
      do j=jps, jpe
       do k=1,num_metgrid_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%u3d(i,k,j)
        enddo
       enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_levels,jps, jpe, &
                                 domain_array, ids, ide, 1, num_metgrid_levels,jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_levels,MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%u3d=domain_array
      call mpi_barrier(local_com, mpi_ierr)

      ! v3d
      do j=jps, jpe
       do k=1,num_metgrid_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%v3d(i,k,j)
        enddo
       enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_levels,jps, jpe, &
                                 domain_array, ids, ide, 1, num_metgrid_levels,jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_levels,MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%v3d=domain_array
      call mpi_barrier(local_com, mpi_ierr)

      ! t3d
      do j=jps, jpe
       do k=1,num_metgrid_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%t3d(i,k,j)
        enddo
       enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_levels,jps, jpe, &
                                 domain_array, ids, ide, 1, num_metgrid_levels,jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_levels,MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%t3d=domain_array
      call mpi_barrier(local_com, mpi_ierr)

      ! qv3d
      do j=jps, jpe
       do k=1,num_metgrid_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%qv3d(i,k,j)
        enddo
       enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_levels,jps, jpe, &
                                 domain_array, ids, ide, 1, num_metgrid_levels,jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_levels,MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%qv3d=domain_array
      call mpi_barrier(local_com, mpi_ierr)
      
      ! qc3d
      do j=jps, jpe
       do k=1,num_metgrid_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%qc3d(i,k,j)
        enddo
       enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_levels,jps, jpe, &
                                 domain_array, ids, ide, 1, num_metgrid_levels,jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_levels,MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%qc3d=domain_array
      call mpi_barrier(local_com, mpi_ierr)

      ! qi3d
      do j=jps, jpe
       do k=1,num_metgrid_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%qi3d(i,k,j)
        enddo
       enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_levels,jps, jpe, &
                                 domain_array, ids, ide, 1, num_metgrid_levels,jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_levels,MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%qi3d=domain_array
      call mpi_barrier(local_com, mpi_ierr)      

      ! rh3d
      do j=jps, jpe
       do k=1,num_metgrid_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%rh3d(i,k,j)
        enddo
       enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1,num_metgrid_levels,jps, jpe, &
                                 domain_array, ids, ide, 1,num_metgrid_levels,jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_levels,MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%rh3d=domain_array
      call mpi_barrier(local_com, mpi_ierr)

      ! z3d
      do j=jps, jpe
       do k=1,num_metgrid_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%z3d(i,k,j)
        enddo
       enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_levels,jps, jpe, &
                                 domain_array, ids, ide, 1, num_metgrid_levels,jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_levels,MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%z3d=domain_array
      call mpi_barrier(local_com, mpi_ierr)

      ! taucldv3d
      do j=jps, jpe
       do k=1,num_metgrid_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%taucldv3d(i,k,j)
        enddo
       enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_levels,jps, jpe, &
                              domain_array, ids, ide, 1, num_metgrid_levels,jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_levels,MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%taucldv3d=domain_array
      call mpi_barrier(local_com, mpi_ierr)      

      ! taucldi3d
      do j=jps, jpe
       do k=1,num_metgrid_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%taucldi3d(i,k,j)
        enddo
       enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_levels,jps, jpe, &
                              domain_array, ids, ide, 1, num_metgrid_levels,jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_levels,MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%taucldi3d=domain_array
      call mpi_barrier(local_com, mpi_ierr) 
      
      deallocate(patch_array)
      deallocate(domain_array)

     allocate(patch_array(ips:ipe,1:num_metgrid_soil_levels,jps:jpe))
     allocate(domain_array(ids:ide,1:num_metgrid_soil_levels,jds:jde))

      ! soilt
      do j=jps, jpe
       do k=1,num_metgrid_soil_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%soilt(i,k,j)
        enddo
       enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_soil_levels, jps, jpe, &
                              domain_array, ids, ide, 1, num_metgrid_soil_levels, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_soil_levels, MPI_DOUBLE_PRECISION, 0, local_com, ierror)                                    
      grid%soilt=domain_array
      
      ! soilm
      do j=jps, jpe
       do k=1,num_metgrid_soil_levels
        do i=ips, ipe
          patch_array(i,k,j)=grid%soilm(i,k,j)
        enddo
       enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, num_metgrid_soil_levels, jps, jpe, &
                              domain_array, ids, ide, 1, num_metgrid_soil_levels, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1)*num_metgrid_soil_levels, MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      grid%soilm=domain_array      
      
      deallocate(patch_array)
      deallocate(domain_array)
      
      allocate(patch_array(ips:ipe,1:1,jps:jpe))
      allocate(domain_array(ids:ide,1:1,jds:jde))
      
      ! snow
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%snowh(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                           
         grid%snowh(i,j)=domain_array(i,1,j)
        enddo
      enddo
                
     if(1.eq.0) then
     ! no use of xland, tsk, sst and ht during the integration
     ! xland
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%xland(i,j)
        enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide
         grid%xland(i,j)=domain_array(i,1,j)
        enddo
      enddo

      ! ht
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%ht(i,j)
        enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide
         grid%ht(i,j)=domain_array(i,1,j)
        enddo
      enddo

      ! tsk
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%tsk(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0,local_com, ierror)
      do j=jds, jde
        do i=ids, ide
         grid%tsk(i,j)=domain_array(i,1,j)
        enddo
      enddo

      ! sst
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%sst(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                           
         grid%sst(i,j)=domain_array(i,1,j)
        enddo
      enddo
      
      end if

      ! xice
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%xice(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                           
         grid%xice(i,j)=domain_array(i,1,j)
        enddo
      enddo
      
      ! psfc
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%ps(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                           
         grid%ps(i,j)=domain_array(i,1,j)
        enddo
      enddo
      
      ! raincv
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%raincv(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%raincv(i,j)=domain_array(i,1,j)
        enddo
      enddo   
      
      ! rainncv
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%rainncv(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%rainncv(i,j)=domain_array(i,1,j)
        enddo
      enddo
    
      ! u10
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%u10(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%u10(i,j)=domain_array(i,1,j)
        enddo
      enddo
  
      ! v10
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%v10(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%v10(i,j)=domain_array(i,1,j)
        enddo
      enddo      
 
      ! t2
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%t2(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%t2(i,j)=domain_array(i,1,j)
        enddo
      enddo

      ! q2
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%q2(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%q2(i,j)=domain_array(i,1,j)
        enddo
      enddo
 
      ! rh2
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%rh2(i,j)
        enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0,local_com, ierror)
      do j=jds, jde
        do i=ids, ide
         grid%rh2(i,j)=domain_array(i,1,j)
        enddo
      enddo

      ! pblh
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%pblh(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%pblh(i,j)=domain_array(i,1,j)
        enddo
      enddo
   
      ! ust
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%ust(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%ust(i,j)=domain_array(i,1,j)
        enddo
      enddo

      ! rmol
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%rmol(i,j)
        enddo
      enddo
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0,local_com, ierror)
      do j=jds, jde
        do i=ids, ide
         grid%rmol(i,j)=domain_array(i,1,j)
        enddo
      enddo

      ! swdown
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%swdown(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%swdown(i,j)=domain_array(i,1,j)
        enddo
      enddo

      ! clflo
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%clflo(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%clflo(i,j)=domain_array(i,1,j)
        enddo
      enddo      
 
      ! clfmi
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%clfmi(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%clfmi(i,j)=domain_array(i,1,j)
        enddo
      enddo  
 
      ! clfhi
      do j=jps, jpe
        do i=ips, ipe
          patch_array(i,1,j)=grid%clfhi(i,j)
        enddo
      enddo 
      call gather_whole_field(patch_array, ips, ipe, 1, 1, jps, jpe, &
                              domain_array, ids, ide, 1, 1, jds, jde)
      call mpi_bcast(domain_array, (ide-ids+1)*(jde-jds+1), MPI_DOUBLE_PRECISION, 0, local_com, ierror)
      do j=jds, jde
        do i=ids, ide                         
         grid%clfhi(i,j)=domain_array(i,1,j)
        enddo
      enddo  

      deallocate(patch_array)
      deallocate(domain_array)

   end subroutine garther_camgrid
!===============================================================================

      Subroutine interpolate_to_pressure_levels(kps,kpe &
                   ,nx,ny,nz &
                   ,P,P_int,field_data,field_data_int)

       implicit none
       integer,intent(in) :: kps,kpe,nx,ny,nz
       real*8, dimension(nx,kps:kpe,ny), intent(in) :: field_data
       real*8, dimension(nx,kps:kpe,ny), intent(in) :: p
       real*8, dimension(nx,nz,ny), intent(in) :: P_int
       real*8, dimension(nx,nz,ny), intent(out) :: field_data_int          
        
       real*8 :: X(kpe-kps+1),Y(kpe-kps+1),Y2(kpe-kps+1),XINT,YINT,yp1,ypn
       integer :: i,j,k

       yp1=2e30
       ypn=2e30
       ! interpolate from sigma to pressure coordinates:
       do j=1,ny
       do i=1,nx 
        do k=kps,kpe
         X(k-kps+1)=P(i,k,j)*1.0_8
         Y(k-kps+1)=field_data(i,k,j)*1.0_8
        enddo
        call spline(X,Y,yp1,ypn,kpe-kps+1,Y2)
        do k=1,nz
         XINT=P_int(i,k,j)*1.0_8
         call splint(X,Y,Y2,kpe-kps+1,XINT,YINT)
         field_data_int(i,k,j)=YINT
        end do
       end do
       end do
       return
      end subroutine interpolate_to_pressure_levels

!===============================================================================

       SUBROUTINE spline(x,y,yp1,ypn,n,y2) 
             implicit none
             INTEGER :: n
             INTEGER, parameter :: NMAX=500
             REAL*8 :: x(n),y(n),y2(n) 
             INTEGER :: i,k
             REAL*8 :: p,qn,sig,un,u(NMAX),yp1,ypn
  
           if(yp1.gt..99e30) then
             y2(1)=0
             u(1)=0
           else
             y2(1)=-0.5
             u(1)=(3./(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1)
           endif
  
             do i=2,n-1
             sig=(x(i)-x(i-1))/(x(i+1)-x(i-1))
             p=sig*y2(i-1)+2.
             y2(i)=(sig-1.)/p
             u(i)=(6.*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1)) &
             /(x(i)-x(i-1)))/(x(i+1)-x(i-1))-sig*u(i-1))/p
             end do

           if(ypn.gt..99e30) then
             qn=0
             un=0
           else              
             qn=0.5
             un=(3./(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))
            endif
  
             y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.)
             
             do k=n-1,1,-1
             y2(k)=y2(k)*y2(k+1)+u(k)
             end do
             
             return
             
       end SUBROUTINE spline

!===============================================================================
        
       SUBROUTINE splint(xa,ya,y2a,n,x,y)
         implicit none
         INTEGER :: n
         REAL*8 :: x,y,xa(n),y2a(n),ya(n)
         INTEGER :: k,khi,klo
         REAL*8 :: a,b,h

         ! Eli: avoid actual extrapolation by using the end values:
         if (x<xa(n)) then
                 y=ya(n)
         elseif (x>xa(1)) then
                 y=ya(1)
         else
         ! Eli: end of my addition here.
                 klo=1
                 khi=n
   1    if (khi-klo.gt.1) then
             k=(khi+klo)/2
         if(xa(k).lt.x)then
                 khi=k
         else
                 klo=k
         end if
         goto 1
        end if
        h=xa(khi)-xa(klo)
        if (h.eq.0.) pause 'bad xa input in splint'
        a=(xa(khi)-x)/h
        b=(x-xa(klo))/h
        y=a*ya(klo)+b*ya(khi)+ &
          ((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.
        end if
        return
       end SUBROUTINE splint

end module geatm_comp_mct
